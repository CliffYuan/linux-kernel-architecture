<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>完成量|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 完成量..." name="description"/>
  <meta content="完成量," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/completion/" />
  <meta property="og:title" content="完成量" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 完成量..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">Home</a></li>
  <li><a href="/archive/">Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/">Kernel</a></li>
</ul>

</div>

<div class="container">

<div class="main clearfix">
  <div class="title">完成量</div>

  <div class="content process进程_content_css">
    <p>完成量（<em>completion</em>）机制基于等待队列，内核利用这个机制等待某一个操作结束，这两种机制使用得都比较频繁，主要用于设备的驱动程序。完成量与信号量有些相似，但完成量是基于等待队列实现的。</p>

<p>我们只感兴趣完成量的接口。在场景中有两个参与者，一个在等待某操作的完成，而另一个在操作完成时发出声明，实际上，这已经被简化过了。实际上，可以有任意数目的进程等待操作完成，为表示进程等待的即将完成的『某操作』，内核使用了<em>complietion</em>数据结构，代码如下：</p>

<h4 id="kernelcompletionh">&lt;kernel/completion.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">completion</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">done</span><span class="p">;</span>
    <span class="n">wait_queue_head_t</span> <span class="n">wait</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>我们可以看到<em>wait</em>变量是一个<em>wait_queue_head_t</em>结构体，是等待队列链表的头，<em>done</em>是一个计数器。每次调用<em>completion</em>时，该计数器就加1，仅当<em>done</em>等于0时，<em>wait_for</em>系列函数才会使调用进程进入睡眠。实际上，这意味着进程无需等待已经完成的事件。</p>

<p>其中<em>wait_queue_head_t</em>已经在等待队列中记录过了，代码如下：</p>

<h4 id="linuxwaith">&lt;linux/wait.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">__wait_queue_head</span> <span class="p">{</span>
    <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">task_list</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">__wait_queue_head</span> <span class="n">wait_queue_head_t</span><span class="p">;</span></code></pre></div>

<p><em>init_completion()</em>函数用于初始化一个动态分配的<em>completion</em>实例，而<em>DECLARE_COMPLETION</em>宏用来建立该数据结构的静态实例。<em>init_completion()</em>函数代码如下：</p>

<h4 id="kernelcompletionh-1">&lt;kernel/completion.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">init_completion</span><span class="p">(</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span><span class="o">-&gt;</span><span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>从上面代码中可以看到，初始化完成量会将<em>done</em>字段初始化为0，并且初始化<em>wait</em>链表。进程可以用<em>wait_for_completion</em>添加到等待队列，进程在其中等待，并以独占睡眠状态直到请求被内核的某些部分处理，这些函数都需要一个<em>completion</em>实例：</p>

<h4 id="kernelcompletionh-2">&lt;kernel/completion.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">extern</span> <span class="kt">void</span>
<span class="n">wait_for_completion</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>
<span class="n">wait_for_completion_interruptible</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">int</span>
<span class="n">wait_for_completion_killable</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="n">wait_for_completion_timeout</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span>
<span class="n">wait_for_completion_interruptible_timeout</span><span class="p">(</span>
        <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timeout</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span>
<span class="n">try_wait_for_completion</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">bool</span>
<span class="n">completion_done</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">x</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span>
<span class="n">complete</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="p">);</span>

<span class="k">extern</span> <span class="kt">void</span>
<span class="n">complete_all</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="p">);</span></code></pre></div>

<p>通常进程在等待事件的完成时处于不可中断状态，但如果使用<em>wait_for_completion_interruptible</em>可以改变这一设置，如果进程被中断，则函数返回<em>-ERESTARTSYS</em>，否则返回0.</p>

<p><em>wait_for_completion_timeout</em>等待一个完成事件发送，但提供了超时的设置，如果等待时间超过了这一设置，则取消等待。这有助于防止无限等待某一时间，如果在超时之间就已经完成，函数就返回剩余时间，否则就返回0。</p>

<p><em>wait_for_completion_interruptible_timeout</em>是前两种的结合体。</p>

<p>在请求由内核的另一部分处理之后，必须调用<em>complete</em>或者<em>complete_all</em>来唤醒等待的进程。因为每次调用只能从完成量的等待队列移除一个进程，对<em>n</em>个等待进程来说，必须调用函数<em>n</em>次。另一方面，<em>complete_all</em>会唤醒所有等待该完成的进程。</p>

<p>除此之外，还有<em>complete_and_exit</em>方法，该方法是一个小的包装起，首先调用<em>complete</em>，然后调用<em>do_exit</em>结束内核线程。</p>

<h4 id="kernelexitc">&lt;kernel/exit.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">NORET_TYPE</span> <span class="kt">void</span> <span class="nf">complete_and_exit</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">comp</span><span class="p">,</span>
    <span class="kt">long</span> <span class="n">code</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">comp</span><span class="p">)</span>
        <span class="n">complete</span><span class="p">(</span><span class="n">comp</span><span class="p">);</span>

    <span class="n">do_exit</span><span class="p">(</span><span class="n">code</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>在<em>completion</em>结构体中，<em>done</em>是一个计数器。<em>complete_all</em>的工作方式与之类似，但它会将计数器设置为最大的可能值，这样，在事件完成后调用<em>wait_for</em>系列函数的进程将永远不会睡眠。</p>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#完成量">#完成量</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/wait-queue/" class="pre">&lt; 等待队列</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/init-slab/" class="next">slab初始化 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments process进程_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章完成量写于2014年05月11日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
