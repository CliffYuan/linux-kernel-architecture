<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>内核一致性|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 内核一致性..." name="description"/>
  <meta content="一致性,抢占式,中断,信号量,内核," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/consistent-of-kernel/" />
  <meta property="og:title" content="内核一致性" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 内核一致性..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">Home</a></li>
  <li><a href="/archive/">Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/">Kernel</a></li>
</ul>

</div>

<div class="container">

<div class="main clearfix">
  <div class="title">内核一致性</div>

  <div class="content basic基础_content_css">
    <p>内核的另一个重要的保证就是一致性（<em>consistent</em>）状态，如果内核对某一个控制路径所需要的数据进行挂起，那么其他的内核控制路径<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>就不应该再对这个数据进行修改，除非重新被设置成一致性状态。否则会给计算机造成非常严重的数据伤害<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>。</p>

<p>当某个计算结果取决于如何调度两个或多个进程时，相关代码就时不正确的，这是一种竞争条件（<em>race condition</em>）。要避免这种情况，对全局变量的安全访问通过原子操作（atomic operation）。这种问题和线程安全面临的是同样问题，但内核需要更加严谨的对待。不过，现在已经有几种技术被采用，以便同步内核控制路径。</p>

<h3 id="section">非抢占式内核</h3>

<p>一个最简单的解决办法就是使用非抢占式内核，大多数传统的Unix内核都是非抢占式的，当进程在内核态执行时，它不能被任意一个程序挂起，也不能被任意另一个进程代替。因此，在这种系统上，中断或异常处理程序不能修改所有内核的数据结构，内核对它们来说时安全的。</p>

<p>除了内核态的进程能自愿放弃CPU，这种情况下，它必须保证所有的数据都处于一致性状态。此外，当这种进程恢复执行时，它必须重新检查以前访问过的数据结构的值，因为这些数据有可能被改变。</p>

<p><strong>非抢占式内核在多处理器系统上是低效的</strong>，因为多CPU上的两个内核控制路径可以并发的访问相同的数据结构。</p>

<h3 id="section-1">禁止中断</h3>

<p>单处理器的另一种同步机制是，在进入一个临界区之前禁止所有的硬件中断，离开时再重新启动。这种机制简单但不是最佳，如果临界区比较大，那么一个相对较长的时间内都会禁止中断，使所有的硬件都处于不可用状态。这也是一种低效的解决方法。</p>

<h3 id="section-2">信号量</h3>

<p>广泛使用的一种机制是信号量（<em>semaphore</em>），它在单处理器系统和多处理器系统上都有效。信号量仅仅是一个与数据结构相关的计数器，所有内核线程在试图访问这个数据之前，都需要检查这个信号量<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>。组成如下：</p>

<ol>
  <li>一个整数变量。</li>
  <li>一个等待进程的链表。</li>
  <li>两个原子方法，down()和up()。</li>
</ol>

<p>down方法是对信号量减1，up则相反。如果信号量新的数值小于0，此方法就把正在运行的进程加入到这个信号量链表，然后阻塞该进程。up方法的结果如果大于0或等于0，则激活这个信号量链表里的一个或者多个进程。如果信号量不是负数，则允许访问这个数据结构，否则执行内核控制路径的进程加入到这个信号量链表并阻塞进程。</p>

<h3 id="section-3">自旋锁</h3>

<p>在多处理器系统中，信号量不是最好的解决方法，系统不允许在不同的CPU上运行的控制路径访问相同的内核数据结构，这种情况下，信号量会比较低效<sup id="fnref:4"><a href="#fn:4" class="footnote">4</a></sup>。这种情况下，多处理器系统使用了自旋锁（<em>spin lock</em>）。自旋锁和信号量相似，但没有等待进程链表，当一个进程发现锁被另一个进程锁着时，就不停的『旋转』，执行一个循环等待，直到锁打开。而正时因为多处理器的原因，挂起的进程不会一直挂起，因为另一个CPU终究会释放资源。</p>

<p>所以，自旋锁在单处理器环境下时无效的，当内核控制路径试图访问一个上锁的数据结构，则会无休止的循环，最后的结果可能导致系统挂起。</p>

<h3 id="section-4">死锁</h3>

<p>当进程A需要访问数据结构a，当B需要访问数据结构b，但是A在等待b，而B在等待a，就会出现死锁状态。很难保证操作系统不会出现死锁状态，现在的操作系统通过按规定的顺序请求信号量来避免死锁。</p>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>内核控制路径（<em>kernel control path</em>）表示内核处理系统调用、异常或中断所执行的指令序列。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>例如，计算机中的一个内核控制路径对一个变量A进行读取，这个时候产生了一个中断，或者更高优先级的进程访问，此时后一个也使用变量A并修改数据。执行完毕后，CPU将权限归还与第一个控制路径，并重新读取A，这个时候数据已经发生了变化。 <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>可以把信号量看成一个对象。 <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:4">
      <p>为了检查信号量，内核必须把进程插入到信号量链表里，然后挂起。这两种操作比较耗时，完成这些操作，其他的内核控制路径可能已经释放了信号量。 <a href="#fnref:4" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#一致性">#一致性</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#抢占式">#抢占式</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#中断">#中断</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#信号量">#信号量</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#内核">#内核</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/reentrant-kernel/" class="pre">&lt; 可重入内核</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/signal/" class="next">进程间的通信 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments basic基础_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章内核一致性写于2014年03月17日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
