<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>目录项高速缓存|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 目录项高速缓存..." name="description"/>
  <meta content="目录项,高速缓存," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/dentry-cache/" />
  <meta property="og:title" content="目录项高速缓存" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 目录项高速缓存..." />
</head>
<body>

<div class="banner">
<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/" class="glyphicon glyphicon-inbox"> Home</a></li>
  <li><a href="/archive" class="glyphicon glyphicon-floppy-disk"> Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/" class="glyphicon glyphicon-book"> Kernel</a></li>
  <li><a href="/about" class="glyphicon glyphicon-record"> About</a></li>
</ul>
</div>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">目录项高速缓存</div>

  <div class="content 虚拟文件系统_content_css">
    <p>由于从磁盘读入一个目录项并构造相应的目录项对象需要花费大量的时间，所以，再完成对目录项对象的操作后，可能后面还要使用它，因此仍在内存中保留它有重要的意义。例如，我们经常需要编译文件，随后编译它，或者编辑并打印它，或者复制它并编辑这个拷贝，再诸如此类的情况中，同一个文件需要被反复访问。</p>

<p>为了最大限度地提高处理这些目录项对象的效率，Linux使用目录项高速缓存，它由两种类型的数据结构组成：</p>

<ol>
  <li>一个处于正在使用，未使用或负状态的目录项对象的集合。</li>
  <li>一个散列表，从中能够快速获取与给定的文件名和目录名对应的目录项对象，同样，如果访问的对象不在目录项高速缓存中，则散列函数返回一个空值。</li>
</ol>

<p>目录项高速缓存的作用还相当于索引节点高速缓存（<em>inode cache</em>）的控制器，在内核内存中，并不丢弃与未用目录项相关的索引节点，这是由于目录项高速缓存仍在使用它们。因此，这些索引节点对象保存在RAM中，并能够借助相应的目录项快速引用它们。</p>

<p>所有未使用的目录项对象都放在一个『最近最少使用（LRU）』的双向链表中，该链表按照插入的时间排序，也就是说，最后释放的目录项对象放在链表的首部，所以最近最少使用的目录项对象总是靠近链表的尾部。</p>

<p>一旦目录项高速缓存的空间开始变小，内核就从链表的尾部删除元素，使得最近最常使用的对象得以保留，LRU链表的首元素和尾元素的地址存放在<em>list_headr</em>类型的<em>dentry_unused</em>变量的<em>next</em>字段和<em>prev</em>字段中，目录项对象的<em>d_lru</em>字段包含指向链表中相邻目录项的指针。</p>

<p>每个正在使用的目录项对象都被插入一个双向链表中，该链表由相应索引节点对象的<em>i_dentry</em>字段所指向。目录项对象的<em>d_alias</em>字段存放链表中相邻元素的地址，从前面的对象笔记中就可以清楚的明白。</p>

<p>当指向相应文件的最后一个硬连接被删除后，一个正在使用的目录项对象可能会变成负状态。在这种情况下，该目录项对象被移到未使用目录项对象组成的LRU链表中。每当内核缩减目录项高速缓存时，负状态目录项对象就朝着LRU链表的尾部移动，这样这些对象就会被逐渐释放。</p>

<p>散列表是由<em>dentry_hashtable</em>数组实现的。数组中的每个元素时一个指向链表的指针，这种链表就是把具有相同散列表值的目录项进行散列而成的。该数组的长度取决于系统已安装RAM的数量，缺省值时每兆字节RAM包含256个元素。</p>

<p>目录项对象的<em>d_hash</em>字段包含指向具有相同散列值的链表中的相邻元素，散列函数产生的值是由目录的目录项对象及文件名计算出来的。</p>

<p><em>dcache_lock</em>自旋锁保护目录项高速缓存数据结构免受多处理器系统上的同时访问。<em>d_lookup()</em>函数在散列表中查找给定的父目录对象和文件名，为了避免发生竞争，使用顺序锁。<em>__d_lookup()</em>函数与之类似，但假定不会发生竞争，因此也不需要顺序锁。</p>

<h4 id="fsdcachec">&lt;fs/dcache.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="nf">d_lookup</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">dentry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">seq</span><span class="p">;</span>

        <span class="k">do</span> <span class="p">{</span>
                <span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
                <span class="n">dentry</span> <span class="o">=</span> <span class="n">__d_lookup</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p><em>d_lookup()</em>函数最终会调用到<em>__d_lookup()</em>函数。</p>

<h4 id="fsdcachec-1">&lt;fs/dcache.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="nf">__d_lookup</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span> <span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span> <span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hash</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">hash</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span> <span class="o">=</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">hlist_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="n">d_hash</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span><span class="n">hash</span><span class="p">);</span>
    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">hlist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>

    <span class="n">rcu_read_lock</span><span class="p">();</span>
    
    <span class="n">hlist_for_each_entry_rcu</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">d_hash</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">hash</span> <span class="o">!=</span> <span class="n">hash</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>

        <span class="cm">/*
         * 在上锁之后重新检查目录项因为
         * d_move可能会更改一些其他属性
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">parent</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">d_unhashed</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
            <span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

        <span class="cm">/*
         * 因为d_mode()不能修改qstr，因为被自旋锁保护
         * 所以检查和比较名字是安全的
         */</span>
        <span class="n">qstr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_op</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_compare</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_op</span><span class="o">-&gt;</span><span class="n">d_compare</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">qstr</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>
                <span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">qstr</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">qstr</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
                <span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span><span class="p">);</span>
        <span class="cm">/* 找到了 */</span>
        <span class="n">found</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
<span class="nl">next:</span>
        <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">rcu_read_unlock</span><span class="p">();</span>
    <span class="cm">/* 返回命中的缓存项 */</span>
    <span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>可以看到，缓存项的相关逻辑并不是那么复杂。</p>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#目录项">#目录项</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#高速缓存">#高速缓存</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/dentry-object/" class="pre">&lt; 目录项对象</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/special-filesystem/" class="next">特殊文件系统 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 虚拟文件系统_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章目录项高速缓存写于2014年05月17日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
