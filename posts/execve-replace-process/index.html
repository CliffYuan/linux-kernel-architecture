<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>进程替换|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 替换进程..." name="description"/>
  <meta content="进程替换,execve," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/execve-replace-process/" />
  <meta property="og:title" content="进程替换" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 替换进程..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">Home</a></li>
  <li><a href="/archive/">Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/">Kernel</a></li>
</ul>

</div>

<div class="container">

<div class="main clearfix">
  <div class="title">进程替换</div>

  <div class="content process进程_content_css">
    <p>可以通过新代码替换现存的程序，即可以启用新程序。Linux提供的execve系统调用可以用于该目的。C标准库中有其他的exec变体，但最终都基于execve。</p>

<p>execve的入口点是体系结构相关的sys_execve函数，该函数很快将工作委托给体系结构无关的do_execve例程。</p>

<h4 id="fsexecc">&lt;fs/exec.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">do_execve</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">filename</span><span class="p">,</span>
    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__user</span> <span class="o">*</span><span class="n">argv</span><span class="p">,</span>
    <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">__user</span> <span class="o">*</span><span class="n">envp</span><span class="p">,</span>
    <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span> <span class="n">regs</span><span class="p">){</span>
<span class="p">}</span></code></pre></div>

<p>这里不仅用参数传递了寄存器集合和可执行文件的名称（<em>filename</em>），而且还传递了指向程序的参数和环境的指针，这里的记号稍微有些笨拙，因为argv和envp都是指针数组，而且指向的两个数组自身的指针以及数组中的所有指针都位于虚地址的用户空间部分。</p>

<p>do_execve代码流程图如下：</p>

<p class="center"><img src="/linux-kernel-architecture/images/execve.png" alt="system" style="max-width:500px" /></p>

<p class="center">进程替换流程图</p>

<p>首先打开要执行的文件，内核找到相关的inode并生成一个文件描述符，用于寻址该文件。bprm_init接下来处理若干管理性任务，例如mm_alloc生成一个新的mm_struct实例来管理进程地址空间。init_new_context是一个特定于体系结构的函数，用于初始化该实例，而__bprm_mm_init则建立初始的栈。</p>

<p>prepare_binprm用于提供一些父进程相关的值，特别是有效的UID和GID，剩余的数据，参数列表直接复制到结构中。简约代码如下：</p>

<h4 id="fsexecc-1">&lt;fs/exec.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="nf">prepare_binprm</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="o">-&gt;</span><span class="n">mnt_flags</span> <span class="o">&amp;</span> <span class="n">MNT_NOSUID</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* Set-uid? */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_ISUID</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">per_clear</span> <span class="o">|=</span> <span class="n">PER_CLEAR_ON_SETID</span><span class="p">;</span>
            <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="cm">/* Set-gid? */</span>
        <span class="cm">/*
         * If setgid is set but no group execute bit then this
         * is a candidate for mandatory locking, not a setgid
         * executable.
         */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">S_ISGID</span> <span class="o">|</span> <span class="n">S_IXGRP</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">S_ISGID</span> <span class="o">|</span> <span class="n">S_IXGRP</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">per_clear</span> <span class="o">|=</span> <span class="n">PER_CLEAR_ON_SETID</span><span class="p">;</span>
            <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>在确认文件来源卷在装载是没有置位MNT_NOSUID之后，内核会监测SUID或SGID是否置位。第一种情况很容易处理，如果S_ISUID置位，那么有效的UID和inode相同，否则使用进程的有效UID。SGID类似，但内核还需要确认组执行位也已经置位。</p>

<p>search_binary_handler用于在do_execve结束是查找一种适当的二进制格式，用于所要执行的特定文件。可以看作根据不同的可执行文件格式来选择适当的程序。二进制格式处理程序负责将新程序的数据加载到旧的地址空间中。通常，二进制格式处理程序执行下列操作。</p>

<ol>
  <li>释放原进程使用的所有资源。</li>
  <li>将应用程序隐射到虚拟地址空间中。</li>
  <li>设置进程的指令指针和其他特定于体系结构的寄存器，以便在调度程序选择该进程的时候开始执行。</li>
</ol>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#进程替换">#进程替换</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#execve">#execve</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/clone-fork-and-vfork/" class="pre">&lt; 进程复制</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/group-exit-and-do-exit-a-process/" class="next">进程退出 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments process进程_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章进程替换写于2014年04月11日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
