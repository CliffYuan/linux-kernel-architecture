<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>堆|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 Heap..." name="description"/>
  <meta content="heap,堆,数据结构," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/heap/" />
  <meta property="og:title" content="堆" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 Heap..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">Home</a></li>
  <li><a href="/archive/">Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/">Kernel</a></li>
</ul>

</div>

<div class="container">

<div class="main clearfix">
  <div class="title">堆</div>

  <div class="content datastruct数据结构_content_css">
    <p>Heap是一种数据结构，内核里经常使用，例如优先级队列，进程调度等等。Heap是一种完全二叉树结构，但是使用数组表示。其操作性能与树的高度成正比。</p>

<h3 id="section">堆的基本性质</h3>

<p>堆用数组表示，由于是完全二叉树，则满足：</p>

<ol>
  <li>t/2表示父节点。</li>
  <li>t*2表示左孩子。</li>
  <li>t*2+1表示右孩子。</li>
</ol>

<p>这里简单的讲解一下创建、插入元素和弹出元素的操作。</p>

<h3 id="code">CODE</h3>

<p>创建一个堆：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="kt">int</span> <span class="n">heap_elem_t</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">heap_t</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="n">heap_elem_t</span> <span class="o">*</span><span class="n">elems</span><span class="p">;</span>
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">cmp</span><span class="p">)(</span><span class="k">const</span> <span class="n">heap_elem_t</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">heap_elem_t</span><span class="o">*</span><span class="p">);</span>
<span class="p">}</span><span class="n">heap_t</span><span class="p">;</span>

<span class="n">heap_t</span><span class="o">*</span>
<span class="n">heap_create</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">capacity</span><span class="p">,</span>
            <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="n">cmp</span><span class="p">)(</span><span class="k">const</span> <span class="n">heap_elem_t</span><span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">heap_elem_t</span><span class="o">*</span><span class="p">)){</span>
    <span class="c1">//给堆分配内存
</span>    <span class="n">heap_t</span> <span class="o">*</span><span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="n">heap_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">heap_t</span><span class="p">));</span>
    <span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">h</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">=</span> <span class="n">capacity</span><span class="p">;</span>
    <span class="c1">//堆的元素本质上是数组
</span>    <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span> <span class="o">=</span> <span class="p">(</span><span class="n">heap_elem_t</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">heap_elem_t</span><span class="p">));</span>
    <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmp</span> <span class="o">=</span> <span class="n">cmp</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">h</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>插入一个元素，基本思想是在数组的最后插入一个元素，然后和父亲比较，如果比父亲小，则交换数据。然后从最后一个元素往前重复之前的和父亲比较的逻辑。</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span>
<span class="nf">heap_push</span><span class="p">(</span><span class="n">heap_t</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="n">heap_elem_t</span> <span class="n">e</span><span class="p">){</span>
    <span class="k">if</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">heap_elem_t</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">heap_elem_t</span><span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">,</span>
            <span class="n">h</span><span class="o">-&gt;</span><span class="n">capacity</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="n">heap_elem_t</span><span class="p">));</span>
        <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
        <span class="n">h</span><span class="o">-&gt;</span><span class="n">capacity</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">]</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>
    <span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">++</span><span class="p">;</span>
    <span class="n">heap_shift_up</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>其中<em>heap_shift_up</em>方法如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span>
<span class="n">heap_shift_up</span><span class="p">(</span><span class="k">const</span> <span class="n">heap_t</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">start</span><span class="p">){</span>
    <span class="c1">// 当前元素
</span>    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="c1">// 父元素
</span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">heap_elem_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>

    <span class="c1">//除非到根节点
</span>    <span class="k">while</span><span class="p">(</span><span class="n">j</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
        <span class="c1">// 比较父元素
</span>        <span class="k">if</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">){</span>
            <span class="c1">// 如果当前元素比父元素小，则直接返回
</span>            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 如果当前元素比父元素大，交换元素
</span>            <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="c1">// 继续往上重复逻辑
</span>            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>堆中弹出逻辑如下，基本思想为把第0个元素弹出，用最后一个元素替换。也就是把最后一个元素拿到跟节点，然后从根节点向下比较。</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span>
<span class="n">heap_pop</span><span class="p">(</span><span class="n">heap_t</span> <span class="o">*</span><span class="n">h</span><span class="p">){</span>
    <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span><span class="o">--</span><span class="p">;</span>
    <span class="n">heap_shift_down</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>其中<em>heap_shift_down</em>逻辑如下：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span>
<span class="n">heap_shift_down</span><span class="p">(</span><span class="k">const</span> <span class="n">heap_t</span> <span class="o">*</span><span class="n">h</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">start</span><span class="p">){</span>
    <span class="c1">// 父节点
</span>    <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">heap_elem_t</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">start</span><span class="p">];</span>

    <span class="c1">// j为子节点中的右孩子，如果不小于size
</span>    <span class="k">for</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">;</span> <span class="n">j</span><span class="o">&lt;</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span> <span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

        <span class="c1">// 如果没有找到最下层的最右节点并且
</span>        <span class="c1">// 比较两个孩子的大小，找到小的那个一
</span>        <span class="k">if</span><span class="p">(</span><span class="n">j</span><span class="o">&lt;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">&amp;&amp;</span>
            <span class="n">h</span><span class="o">-&gt;</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="p">]),</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">){</span>
            <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// 和子节点比较，如果比子节点小，退出
</span>        <span class="k">if</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="p">]))</span><span class="o">&lt;=</span><span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// 如果比子节点大，交换元素
</span>            <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
            <span class="c1">// 继续往下查找
</span>            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">h</span><span class="o">-&gt;</span><span class="n">elems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>完整代码看这个<a href="https://gist.github.com/GuoJing/10355201">GIST</a>。</p>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#heap">#heap</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#堆">#堆</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#数据结构">#数据结构</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/start/" class="pre">&lt; 写在开始</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/how-kernel-work/" class="next">内核 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments datastruct数据结构_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章堆写于2014年03月13日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
