<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>高端内存页框的内核映射|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 高端内存页框的内核映射..." name="description"/>
  <meta content="页框,高端内存,内核映射," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/highmem/" />
  <meta property="og:title" content="高端内存页框的内核映射" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 高端内存页框的内核映射..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">Home</a></li>
  <li><a href="/archive/">Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/">Kernel</a></li>
</ul>

</div>

<div class="container">

<div class="main clearfix">
  <div class="title">高端内存页框的内核映射</div>

  <div class="content 内存管理_content_css">
    <p>与直接映射的物理内存末端，高端内存的始端所对应的线性地址存放在<em>high_memory</em>变量中，它被设置为896MB。896MB边界以上的页框并不映射再内核线性地址空间的第4个GB，因此，内核不能直接访问它们。这就意味着，返回所分配页框线性地址的页分配器函数不适用于高端内存，即不适用于ZONE_HIGHMEM内存管理区的页框。</p>

<p>之前也提到过，假定内核调用__get_free_pages(GFP_HIGHMEM, 0)，则在高端内存区确实申请并分配了一个页框，但是__get_free_pages()不能返回它的线性地址，因为它根本就不存在，所以返回NULL<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。</p>

<p>在32位平台上，必须让内核使用者用所有可以使用的RAM，达到PAE所支持的64GB，所以采用如下方法。</p>

<ul>
  <li>高端内存页框的分配只能通过alloc_pages()函数和它的快捷函数alloc_page()。这些函数不返回第一个被分配的页框的线性地址，因为如果该页属于高端内存，那么这样的线性地址根本不存在。取而代之，这些函数放回第一个被分配页框的页描述符（<em>page</em>）的线性地址，这些线性地址总是存在的<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>。</li>
  <li>没有线性地址的高端内存中的页框不能被内核访问，因此，内核线性地址空间最后128MB中的一部分专门用于映射高端内存页框<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>。当然，这种映射是暂时的，否则只有128MB的高端内存可以被访问。取而代之，通过重复使用线性地址，使得整个高端内存能够在不同的时间被访问。</li>
</ul>

<p>内核可以采用三种不同的机制将页框映射到高端内存，分别叫做永久内核映射、临时内核映射和非连续内存分配。</p>

<h3 id="section">永久内核映射</h3>

<p>建立永久内核映射可能阻塞当前进程，这发生在空闲页表不存在时，页就是高端内存上没有页表项可以用作页框使用时。因此，永久内核映射不能用于中断处理程序和可延迟函数。相反，建立零食内核映射绝不会要求阻塞当前进程。</p>

<p>永久内核映射允许内核建立高端页框到内核地址空间的长期映射，它们使用主内核页表中一个专门的页表，其地址存放在<em>pkmap_page_table</em>变量中。页表中的表项数由<em>LAST_PKMAP</em>宏产生。页表包含512或1024项，这取决于PAE机制是否被激活。因此，内核最多一次性访问2M或4M的高端内存。</p>

<p>页表映射的线性地址从<em>PKMAP_BASE</em>开始，<em>pkmap_count</em>数组包含<em>LAST_PKMAP</em>个计数器，<em>pkmap_page_table</em>页表中的每一个项都有一个。计数器可能为0、1或大于1。</p>

<h4 id="mmhighmemc">&lt;mm/highmem.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="n">pte_t</span> <span class="o">*</span> <span class="n">pkmap_page_table</span><span class="p">;</span></code></pre></div>

<p>如果计数器为0，则说明对应的页表项没有映射任何高端内存，所以是可用的。</p>

<p>如果计数器为1，则说明对应的页表项没有映射任何高端内存，但是不能被使用，因为自从它最后一次使用以来，其TLB表项还未被刷新。</p>

<p>如果计数器大于1，则说明映射一个高端内存页框，这意味着正好有n-1个内核成分在使用这个页框。</p>

<p>为了记录高端内存页框与永久内核映射包含的线性地址之间的联系，内核使用<em>page_address_htable</em>做散列表，它使用<em>page_address_map</em>数据结构用于为高端内存中的每一个页框进行映射。</p>

<h4 id="mmhighmemc-1">&lt;mm/highmem.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">page_address_map</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="k">virtual</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p><em>page_address()</em>函数返回页框对应的线性地址，如果页框在高端内存中并且没有被映射，则返回NULL。</p>

<h4 id="mmhighmemc-2">&lt;mm/highmem.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="o">*</span><span class="nf">page_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">page_address_slot</span> <span class="o">*</span><span class="n">pas</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">lowmem_page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

    <span class="n">pas</span> <span class="o">=</span> <span class="n">page_slot</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pas</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pas</span><span class="o">-&gt;</span><span class="n">lh</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">page_address_map</span> <span class="o">*</span><span class="n">pam</span><span class="p">;</span>

        <span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">pam</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pas</span><span class="o">-&gt;</span><span class="n">lh</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">pam</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">==</span> <span class="n">page</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">pam</span><span class="o">-&gt;</span><span class="k">virtual</span><span class="p">;</span>
                <span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="nl">done:</span>
    <span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pas</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>我们可以从上面的函数可以看出，如果页框不在高端内存中，就通过<em>lowmem_page_address</em>返回线性地址。如果在高端内存中，则通过函数<em>page_slot</em>在<em>page_address_htable</em>中查找，如果在散列表中查找到，就返回线性地址。</p>

<p>kmap()用来建立内存区映射，代码如下：</p>

<h4 id="archarmx86mmhighmem32c">&lt;arch/arm/x86/mm/highmem_32.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="o">*</span><span class="nf">kmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">might_sleep</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">kmap_high</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>本质上如果是高端内存区域，则使用kmap_high()函数用来建立高端内存区的永久内核映射，代码如下：</p>

<h4 id="includelinuxhighmemh">&lt;include/linux/highmem.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="o">*</span><span class="nf">kmap_high</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">;</span>

    <span class="cm">/*
     * For highmem pages, we can't trust "virtual" until
     * after we have the lock.
     */</span>
    <span class="n">lock_kmap</span><span class="p">();</span>
    <span class="n">vaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vaddr</span><span class="p">)</span>
        <span class="n">vaddr</span> <span class="o">=</span> <span class="n">map_new_virtual</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="n">pkmap_count</span><span class="p">[</span><span class="n">PKMAP_NR</span><span class="p">(</span><span class="n">vaddr</span><span class="p">)]</span><span class="o">++</span><span class="p">;</span>
    <span class="n">BUG_ON</span><span class="p">(</span><span class="n">pkmap_count</span><span class="p">[</span><span class="n">PKMAP_NR</span><span class="p">(</span><span class="n">vaddr</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">);</span>
    <span class="n">unlock_kmap</span><span class="p">();</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span> <span class="n">vaddr</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<h3 id="section-1">临时内存映射</h3>

<p>虽然不像永久内存映射那样会阻塞当前进程，但缺点时只有很少的临时内核映射可以同时建立起来。临时内存映射的内核控制路径必须保证当前没有其他的内核控制路径在使用同样的映射。这意味着内核控制路径永远不能被阻塞，否则只其他的内核控制路径有可能使用同一个窗口来映射其他的高端内存页。</p>

<p>临时内核映射比永久内核映射要简单，此外，它们可以用在中断处理程序和可延迟函数的内部，因为它们从不阻塞当前进程。在高端内存的仁一页框都可以通过一个『窗口』映射到内核地址空间。留给临时内核映射的窗口是非常少的。</p>

<p>每个CPU都有它自己包含的13个窗口集合，它们用<em>enum km_type</em>数据结构表示。</p>

<h4 id="includeasm-generickmaptypesh">&lt;include/asm-generic/kmap_types.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">enum</span> <span class="n">km_type</span> <span class="p">{</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>   <span class="n">KM_BOUNCE_READ</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>   <span class="n">KM_SKB_SUNRPC_DATA</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>   <span class="n">KM_SKB_DATA_SOFTIRQ</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>   <span class="n">KM_USER0</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>   <span class="n">KM_USER1</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>   <span class="n">KM_BIO_SRC_IRQ</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">6</span><span class="p">)</span>   <span class="n">KM_BIO_DST_IRQ</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">7</span><span class="p">)</span>   <span class="n">KM_PTE0</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>   <span class="n">KM_PTE1</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>   <span class="n">KM_IRQ0</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="n">KM_IRQ1</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">11</span><span class="p">)</span>  <span class="n">KM_SOFTIRQ0</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>  <span class="n">KM_SOFTIRQ1</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>  <span class="n">KM_SYNC_ICACHE</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">14</span><span class="p">)</span>  <span class="n">KM_SYNC_DCACHE</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>  <span class="n">KM_UML_USERCOPY</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>  <span class="n">KM_IRQ_PTE</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>  <span class="n">KM_NMI</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>  <span class="n">KM_NMI_PTE</span><span class="p">,</span>
<span class="n">KMAP_D</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>  <span class="n">KM_TYPE_NR</span>
<span class="p">};</span></code></pre></div>

<p>这个数据结构中定义的每一个符号都标识了窗口的线性地址。</p>

<p>为了建立临时内核映射，内核调用<em>kmap_atomic()</em>函数。在后来的内核代码中，<em>kmap_atomic()</em>函数只是使用了<em>kmap_atomic_prot</em>。</p>

<h4 id="archarmx86mmhighmem32c-1">&lt;arch/arm/x86/mm/highmem_32.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="o">*</span><span class="nf">kmap_atomic_prot</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">enum</span> <span class="n">km_type</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">kmap</span><span class="p">;</span>

    <span class="n">pagefault_disable</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageHighMem</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">page_address</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

    <span class="n">debug_kmap_atomic</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

    <span class="n">kmap</span> <span class="o">=</span> <span class="n">kmap_high_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">kmap</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kmap</span><span class="p">;</span>

    <span class="n">idx</span> <span class="o">=</span> <span class="n">type</span> <span class="o">+</span> <span class="n">KM_TYPE_NR</span> <span class="o">*</span> <span class="n">smp_processor_id</span><span class="p">();</span>
    <span class="n">vaddr</span> <span class="o">=</span> <span class="n">__fix_to_virt</span><span class="p">(</span><span class="n">FIX_KMAP_BEGIN</span> <span class="o">+</span> <span class="n">idx</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_DEBUG_HIGHMEM
</span>    <span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">pte_none</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">TOP_PTE</span><span class="p">(</span><span class="n">vaddr</span><span class="p">))));</span>
<span class="cp">#endif
</span>    <span class="n">set_pte_ext</span><span class="p">(</span><span class="n">TOP_PTE</span><span class="p">(</span><span class="n">vaddr</span><span class="p">),</span> <span class="n">mk_pte</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">kmap_prot</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">local_flush_tlb_kernel_page</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>

    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">vaddr</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>在64位的硬件平台上不存在这个问题。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>因为页描述符一旦被分配在地段内存中，它们在内核初始化阶段就不会变。 <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>所以虽然我们有896MB的空间可以分配页框，但实际上并没有这么多的地址空间。 <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#页框">#页框</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#高端内存">#高端内存</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#内核映射">#内核映射</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/page-frame-allocator/" class="pre">&lt; 分区页框分配器</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/init-mm-management/" class="next">初始化内存管理 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 内存管理_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章高端内存页框的内核映射写于2014年04月20日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
