<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>初始化内存域和结点|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 初始化内存域和结点..." name="description"/>
  <meta content="内存空间,内存域,结点,伙伴系统," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/init-mm-zone-and-page/" />
  <meta property="og:title" content="初始化内存域和结点" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 初始化内存域和结点..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">Home</a></li>
  <li><a href="/archive/">Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/">Kernel</a></li>
</ul>

</div>

<div class="container">

<div class="main clearfix">
  <div class="title">初始化内存域和结点</div>

  <div class="content 内存管理_content_css">
    <p>由于内存结构的分配和体系结构相关，早期每个体系结构都要自己准备相关的数据，体系结构相关代码需要在启动期间建立以下数据信息：</p>

<ol>
  <li>系统中各个内存域的页帧边界，保存在<em>max_zone_pfn</em>数组。</li>
  <li>各个结点页帧的分配情况，保存在全局变量<em>early_node_map</em>中。</li>
</ol>

<h3 id="section">管理数据结构的创建</h3>

<p>从内核版本2.6.10开始提供了一个通用的框架，用于将上述信息转换为伙伴系统预期的结点和内存空间的数据结构，在这之前，各个体系结构必须自行建立相关结构。现在，体系结构相关代码只需要建立前述的简单结构，然后将复杂的工作留给<em>free_area_init_nodes</em>即可。</p>

<p class="center"><img src="/linux-kernel-architecture/images/free_area.png" alt="free_area" style="max-width:600px" /></p>

<p class="center">特定体系代码和内核代码之间的作用</p>

<p>上图简单的描述了在建立结点和内存管理区数据结构时，特定于体系结构的代码和通用内核代码之间的相关作用，回到<em>free_area_init_nodes</em>函数本身，流程图如下：</p>

<p class="center"><img src="/linux-kernel-architecture/images/free_area_init_nodes.png" alt="free_area" style="max-width:500px" /></p>

<p class="center">初始化内存域和结点流程图</p>

<p><em>free_area_init_nodes</em>函数代码如下：</p>

<h4 id="mmpageallocc">&lt;mm/page_alloc.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">__init</span> <span class="nf">free_area_init_nodes</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">max_zone_pfn</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nid</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

    <span class="cm">/* 使用堆排序对结构进行简单的排序 */</span>
    <span class="n">sort_node_map</span><span class="p">();</span>

    <span class="cm">/* 记录内存域边界 */</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">arch_zone_lowest_possible_pfn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="n">arch_zone_lowest_possible_pfn</span><span class="p">));</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">arch_zone_highest_possible_pfn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                <span class="k">sizeof</span><span class="p">(</span><span class="n">arch_zone_highest_possible_pfn</span><span class="p">));</span>
    <span class="cm">/* 通过max_zone_pfn传递给free_area_init_nodes
       信息记录了各个内存域包含的最大页帧号 */</span>
    <span class="cm">/* find_min_pfn_with_active_regions 
       用于找到注册的最低内存空间中可用的编号最小的页帧*/</span>
    <span class="n">arch_zone_lowest_possible_pfn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> 
    <span class="n">find_min_pfn_with_active_regions</span><span class="p">();</span>
    <span class="cm">/* max_zone_pfn用于找到最低内存域的最大页帧号*/</span>
    <span class="n">arch_zone_highest_possible_pfn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_zone_pfn</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="cm">/* 直接构建内存空间的页帧区间 */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NR_ZONES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ZONE_MOVABLE</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="n">arch_zone_lowest_possible_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
            <span class="n">arch_zone_highest_possible_pfn</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
        <span class="n">arch_zone_highest_possible_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span>
            <span class="n">max</span><span class="p">(</span><span class="n">max_zone_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">arch_zone_lowest_possible_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
    <span class="n">arch_zone_lowest_possible_pfn</span><span class="p">[</span><span class="n">ZONE_MOVABLE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">arch_zone_highest_possible_pfn</span><span class="p">[</span><span class="n">ZONE_MOVABLE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="cm">/* 找到ZONE_MOVABLE在各个结点的起始编号 */</span>
    <span class="n">memset</span><span class="p">(</span><span class="n">zone_movable_pfn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">zone_movable_pfn</span><span class="p">));</span>
    <span class="n">find_zone_movable_pfns_for_nodes</span><span class="p">(</span><span class="n">zone_movable_pfn</span><span class="p">);</span>

    <span class="cm">/* 输出结点信息 */</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">"Zone PFN ranges:</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NR_ZONES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">ZONE_MOVABLE</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="n">printk</span><span class="p">(</span><span class="s">"  %-8s %0#10lx -&gt; %0#10lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">zone_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">arch_zone_lowest_possible_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="n">arch_zone_highest_possible_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="cm">/* 输出结点信息 */</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">"Movable zone start PFN for each node</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MAX_NUMNODES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">zone_movable_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">printk</span><span class="p">(</span><span class="s">"  Node %d: %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">zone_movable_pfn</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>

    <span class="cm">/* 输出early_node_map[] */</span>
    <span class="n">printk</span><span class="p">(</span><span class="s">"early_node_map[%d] active PFN ranges</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
           <span class="n">nr_nodemap_entries</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_nodemap_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">printk</span><span class="p">(</span><span class="s">"  %3d: %0#10lx -&gt; %0#10lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">early_node_map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nid</span><span class="p">,</span>
                        <span class="n">early_node_map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start_pfn</span><span class="p">,</span>
                        <span class="n">early_node_map</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">end_pfn</span><span class="p">);</span>

    <span class="cm">/* 初始化各个结点 */</span>
    <span class="n">mminit_verify_pageflags_layout</span><span class="p">();</span>
    <span class="n">setup_nr_node_ids</span><span class="p">();</span>
    <span class="n">for_each_online_node</span><span class="p">(</span><span class="n">nid</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>
        <span class="n">free_area_init_node</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                <span class="n">find_min_pfn_for_node</span><span class="p">(</span><span class="n">nid</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="cm">/* 检查结点上是否有内存 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_present_pages</span><span class="p">)</span>
            <span class="n">node_set_state</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">N_HIGH_MEMORY</span><span class="p">);</span>
        <span class="n">check_for_regular_memory</span><span class="p">(</span><span class="n">pgdat</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>在进行大体的初始化之后，开始针对单个结点检查并初始化。</p>

<h4 id="mmpageallocc-1">&lt;mm/page_alloc.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="n">__paginginit</span> <span class="nf">free_area_init_node</span><span class="p">(</span>
        <span class="kt">int</span> <span class="n">nid</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">zones_size</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_start_pfn</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">zholes_size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 创建数据结点的数据结构 */</span>
    <span class="n">pg_data_t</span> <span class="o">*</span><span class="n">pgdat</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="n">nid</span><span class="p">);</span>

    <span class="cm">/* 设置结点的基本信息 */</span>
    <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
    <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">=</span> <span class="n">node_start_pfn</span><span class="p">;</span>
    <span class="cm">/* 该函数累计各个内存空间的页数，计算结点中页的总数，对连续内存
       模型而言，可以通过zone_size_init完成，但这个函数还考虑了内
       存空洞，在启动时，会输出一段简短的消息，如：
       On node 0 totalpages: 131056
     */</span>
    <span class="n">calculate_node_totalpages</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">zones_size</span><span class="p">,</span> <span class="n">zholes_size</span><span class="p">);</span>
    <span class="cm">/* 负责初始化一个简单但非常重要的数据结构 */</span>
    <span class="n">alloc_node_mem_map</span><span class="p">(</span><span class="n">pgdat</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_FLAT_NODE_MEM_MAP
</span>    <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"free_area_init_node: </span><span class="err">
</span><span class="s">           node %d, pgdat %08lx, node_mem_map %08lx</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
        <span class="n">nid</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pgdat</span><span class="p">,</span>
        <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_mem_map</span><span class="p">);</span>
<span class="cp">#endif
</span>
    <span class="n">free_area_init_core</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">zones_size</span><span class="p">,</span> <span class="n">zholes_size</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>其中详细看一下<em>alloc_node_mem_map</em>这个函数：</p>

<h4 id="mmpageallocc-2">&lt;mm/page_alloc.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kt">void</span> <span class="n">__init_refok</span> <span class="nf">alloc_node_mem_map</span><span class="p">(</span>
        <span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 排除掉空结点 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_FLAT_NODE_MEM_MAP
</span>    <span class="cm">/* ia64 体系结构有自己的node_mem_map，需要进行处理 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_mem_map</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>

        <span class="cm">/* 内存分配 */</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">MAX_ORDER_NR_PAGES</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">+</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_spanned_pages</span><span class="p">;</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">MAX_ORDER_NR_PAGES</span><span class="p">);</span>
        <span class="n">size</span> <span class="o">=</span>  <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="p">);</span>
        <span class="n">map</span> <span class="o">=</span> <span class="n">alloc_remap</span><span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="p">)</span>
            <span class="n">map</span> <span class="o">=</span> <span class="n">alloc_bootmem_node</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
        <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_mem_map</span> <span class="o">=</span> <span class="n">map</span> <span class="o">+</span> <span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#ifndef CONFIG_NEED_MULTIPLE_NODES
</span>    <span class="cm">/*
       当pgdata是系统第0个结点
       则mem_map保存指向这个结点的指针
       mem_map是一个全局数组
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pgdat</span> <span class="o">==</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">mem_map</span> <span class="o">=</span> <span class="n">NODE_DATA</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node_mem_map</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_ARCH_POPULATES_NODE_MAP
</span>        <span class="k">if</span> <span class="p">(</span><span class="n">page_to_pfn</span><span class="p">(</span><span class="n">mem_map</span><span class="p">)</span> <span class="o">!=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span><span class="p">)</span>
            <span class="n">mem_map</span> <span class="o">-=</span> <span class="p">(</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span> <span class="o">-</span> <span class="n">ARCH_PFN_OFFSET</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_ARCH_POPULATES_NODE_MAP */</span><span class="cp">
</span>    <span class="p">}</span>
<span class="cp">#endif
#endif </span><span class="cm">/* CONFIG_FLAT_NODE_MEM_MAP */</span><span class="cp">
</span><span class="p">}</span></code></pre></div>

<p>当完成上面的初始化之后，初始化内存域数据结构的工作就交给了<em>free_area_init_core</em>，它会依次遍历结点的所有内存空间。</p>

<p>代码如下：</p>

<h4 id="mmpageallocc-3">&lt;mm/page_alloc.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kt">void</span> <span class="n">__paginginit</span> <span class="nf">free_area_init_core</span><span class="p">(</span><span class="k">struct</span> <span class="n">pglist_data</span> <span class="o">*</span><span class="n">pgdat</span><span class="p">,</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">zones_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">zholes_size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">enum</span> <span class="n">zone_type</span> <span class="n">j</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">nid</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_id</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zone_start_pfn</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_start_pfn</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

    <span class="n">pgdat_resize_init</span><span class="p">(</span><span class="n">pgdat</span><span class="p">);</span>
    <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">nr_zones</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_wait</span><span class="p">);</span>
    <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">kswapd_max_order</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pgdat_page_cgroup_init</span><span class="p">(</span><span class="n">pgdat</span><span class="p">);</span>
    
    <span class="cm">/* 遍历所有的内存空间 */</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">MAX_NR_ZONES</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">zone</span> <span class="o">*</span><span class="n">zone</span> <span class="o">=</span> <span class="n">pgdat</span><span class="o">-&gt;</span><span class="n">node_zones</span> <span class="o">+</span> <span class="n">j</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span><span class="p">,</span> <span class="n">realsize</span><span class="p">,</span> <span class="n">memmap_pages</span><span class="p">;</span>
        <span class="k">enum</span> <span class="n">lru_list</span> <span class="n">l</span><span class="p">;</span>

        <span class="n">size</span> <span class="o">=</span> <span class="n">zone_spanned_pages_in_node</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">zones_size</span><span class="p">);</span>
        <span class="n">realsize</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">zone_absent_pages_in_node</span><span class="p">(</span><span class="n">nid</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span>
                                <span class="n">zholes_size</span><span class="p">);</span>

        <span class="n">memmap_pages</span> <span class="o">=</span>
            <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">realsize</span> <span class="o">&gt;=</span> <span class="n">memmap_pages</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">realsize</span> <span class="o">-=</span> <span class="n">memmap_pages</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">memmap_pages</span><span class="p">)</span>
                <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
                       <span class="s">"  %s zone: %lu pages used for memmap</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                       <span class="n">zone_names</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">memmap_pages</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span>
            <span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
                <span class="s">"  %s zone: %lu pages exceeds realsize %lu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                <span class="n">zone_names</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">memmap_pages</span><span class="p">,</span> <span class="n">realsize</span><span class="p">);</span>

        <span class="cm">/* Account for reserved pages */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">realsize</span> <span class="o">&gt;</span> <span class="n">dma_reserve</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">realsize</span> <span class="o">-=</span> <span class="n">dma_reserve</span><span class="p">;</span>
            <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">"  %s zone: %lu pages reserved</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
                    <span class="n">zone_names</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dma_reserve</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="cm">/* 内核使用nr_kernel_pages统计所有一致映射的页
           而nr_all_pages包括高端内存页在内
         */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_highmem_idx</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
            <span class="n">nr_kernel_pages</span> <span class="o">+=</span> <span class="n">realsize</span><span class="p">;</span>
        <span class="n">nr_all_pages</span> <span class="o">+=</span> <span class="n">realsize</span><span class="p">;</span>

        <span class="cm">/* 初始化各个结点的信息 */</span>
        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">spanned_pages</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">present_pages</span> <span class="o">=</span> <span class="n">realsize</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_NUMA
</span>        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">nid</span><span class="p">;</span>
        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">min_unmapped_pages</span> <span class="o">=</span> 
            <span class="p">(</span><span class="n">realsize</span><span class="o">*</span><span class="n">sysctl_min_unmapped_ratio</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">min_slab_pages</span> <span class="o">=</span> 
            <span class="p">(</span><span class="n">realsize</span> <span class="o">*</span> <span class="n">sysctl_min_slab_ratio</span><span class="p">)</span> <span class="o">/</span> <span class="mi">100</span><span class="p">;</span>
<span class="cp">#endif
</span>        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">zone_names</span><span class="p">[</span><span class="n">j</span><span class="p">];</span>
        <span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
        <span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru_lock</span><span class="p">);</span>
        <span class="n">zone_seqlock_init</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>
        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">zone_pgdat</span> <span class="o">=</span> <span class="n">pgdat</span><span class="p">;</span>

        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">prev_priority</span> <span class="o">=</span> <span class="n">DEF_PRIORITY</span><span class="p">;</span>

        <span class="cm">/* 初始化该内存域的per-CPU缓存 */</span>
        <span class="n">zone_pcp_init</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>
        <span class="n">for_each_lru</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">zone</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">[</span><span class="n">l</span><span class="p">].</span><span class="n">list</span><span class="p">);</span>
            <span class="n">zone</span><span class="o">-&gt;</span><span class="n">reclaim_stat</span><span class="p">.</span><span class="n">nr_saved_scan</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">reclaim_stat</span><span class="p">.</span><span class="n">recent_rotated</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">reclaim_stat</span><span class="p">.</span><span class="n">recent_rotated</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">reclaim_stat</span><span class="p">.</span><span class="n">recent_scanned</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">reclaim_stat</span><span class="p">.</span><span class="n">recent_scanned</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">zap_zone_vm_stats</span><span class="p">(</span><span class="n">zone</span><span class="p">);</span>
        <span class="n">zone</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>

        <span class="n">set_pageblock_order</span><span class="p">(</span><span class="n">pageblock_default_order</span><span class="p">());</span>
        <span class="n">setup_usemap</span><span class="p">(</span><span class="n">pgdat</span><span class="p">,</span> <span class="n">zone</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

        <span class="cm">/* 初始化free_area列表
           并将属于该内存域的所有page实例都设置为默认值 */</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">init_currently_empty_zone</span><span class="p">(</span><span class="n">zone</span><span class="p">,</span> <span class="n">zone_start_pfn</span><span class="p">,</span>
                        <span class="n">size</span><span class="p">,</span> <span class="n">MEMMAP_EARLY</span><span class="p">);</span>
        <span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
        <span class="n">memmap_init</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">nid</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">zone_start_pfn</span><span class="p">);</span>
        <span class="n">zone_start_pfn</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#内存空间">#内存空间</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#内存域">#内存域</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#结点">#结点</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#伙伴系统">#伙伴系统</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/spin-lock/" class="pre">&lt; 自旋锁</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/irq-and-interrupt/" class="next">IRQ和中断 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 内存管理_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章初始化内存域和结点写于2014年05月03日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
