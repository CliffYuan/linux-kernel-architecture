<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>标识进程|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 标识进程..." name="description"/>
  <meta content="标识进程,描述符,task_struct,页框,命名空间,全局ID,局部ID," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/one-process/" />
  <meta property="og:title" content="标识进程" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 标识进程..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">Home</a></li>
  <li><a href="/archive/">Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/">Kernel</a></li>
</ul>

</div>

<div class="container">

<div class="main clearfix">
  <div class="title">标识进程</div>

  <div class="content process进程_content_css">
    <p>能被独立调度的每个执行上下文都必须有自己的进程描述符，因此，使用共享内核大部分数据结构的轻量级进程也有自己的task_struct结构。</p>

<p>进程和进程描述符之间有非常严格的一一对应关系，这使得用32位进程描述符地址标<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>识进程成为一种方便的方式。进程描述符指针指向这些地址，内核对进程的大部分引用是通过进程描述符指针进行的。</p>

<p>另一方面，类Unix操作系统允许用户使用一个叫进程标识符（<em>process ID</em>）的数来标识进程，PID存放在进程描述符pid字段中。PID被顺序变好，新创建的进程的PID通常是前一个进程的PID+1，PID并非无限向上增长。PID有一个最大值上限，当超过了这个上限后，PID就开始循环使用已闲置的小PID号。在默认情况下，最大的PID号是32767<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>。</p>

<p>系统管理员可以通过往<code>/proc/sys/kernel/pid_max</code>这个特殊文件写入一个更小的值来减小PID上限。64位系统PID最大值可以扩展到4194303。</p>

<h3 id="pid">进程PID</h3>

<p>每个进程除了PID这个特征值以外，还有其他的ID，有以下几种可能类型。</p>

<ol>
  <li>处于某个线程组中的所有进程都统一的线程组ID（<em>TGID</em>），如果进程没有使用线程，则PID==TGID。</li>
  <li>独立进程可以合并成进程组，使用setpgrp系统调用即可。</li>
  <li>几个进程组可以合并成一个会话，会话中所有进程都有同样的会话ID，保存在task_struct的session成员中。</li>
</ol>

<h3 id="section">命名空间</h3>

<p>命名空间<sup id="fnref:namespace"><a href="#fn:namespace" class="footnote">3</a></sup>增加了PID管理的复杂性，PID命名空间按照层次组织。在建立一个新的命名空间时，该命名空间中所有PID对父命名空间都是可见的，但子命名空间无法看到父命名空间的信息。但这意味着某些进程有多个PID，凡可以看到该进程的命名空间，都会为其分配一个PID，这必须反映在数据结构中。所以有了全局ID和局部ID。</p>

<ol>
  <li>全局ID时在内核本身和初始命名空间中唯一的ID号，init属于初始命名空间。对每个ID类型，都有一个给定的全局ID。</li>
  <li>局部ID属于某个特定的命名空间，不具备全局有效性，只在命名空间内部有效。</li>
</ol>

<h4 id="schedh">&lt;sched.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
    <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
    <span class="n">pid_t</span> <span class="n">tgid</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<h3 id="pid-1">管理PID</h3>

<p>一个小型的子系统称之为PID分配器用于加速ID的分配，此外内核需要提供辅助函数实现查找task_struct的功能，以及将ID的内核标识形式和用户空间转换。其数据结构大致如下：</p>

<h4 id="pidnamespaceh">&lt;pid_namespace.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">pid_namespace</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">child_reaper</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>于是：</p>

<ol>
  <li>每个PID命名空间都具有一个进程，发挥相当于全局init进程的作用。</li>
  <li>parent时指向父命名空间的指针，level标识当前命名空间在命名空间层次结构中的深度。</li>
</ol>

<p>由于循环使用PID编号，内核必须通过管理一个叫pidmap_array位图来表示当前已分配的PID号和闲置的PID号。因为一个页框包含32768个位，所以在32位体系结构中pidmap_array位图粗放在一个单独的页。在64位体系结构中，当内核分配了超过当前位图大小的PID号时，需要位PID位图增加更多的页，系统会一直保存这些页不被释放。</p>

<p>Linux把不同的PID与系统中每个进程或轻量级进程相关联，这种方式提供最大的灵活性，因为系统中每个执行上下文都可以被唯一的识别。另一方面，Unix程序员希望同一组中的线程有共同的PID，这样就可以把信号发送给指定的PID的一组线程，这个信号会作用于该组中的所有线程。遵照这样的设计，Linux引入线程组，一个线程组中的所有线程使用和该线程组的领头线程（<em>thread group leader</em>）相同的PID，也就是该组中第一个轻量级进程的PID，它被放入进程描述符tgid字段中。getpid()系统调用会返回当前进程的tgid值而不是pid的值。</p>

<p>因此，一个多线程应用的所有线程共享相同的PID。</p>

<h3 id="section-1">进程描述符处理</h3>

<p>进程是动态实体，其生命周期范围从几毫秒到几个月。因此，内核必须能够处理很多进程，并把进程描述符存放在动态内存中。Linux都把两个不同的数据结构紧凑地存放在一个单独为进程分配的存储区域内，一个是与进程描述符相关的小数据结构thread_info，叫做线程描述符。另一个是内核态的进程堆栈。</p>

<p>进程堆栈大小通常为8192个字节。考虑到效率的因素，内核让这8K空间占据连续的两个页框并让第一个页框的起始地址是2^13的倍数。当几乎没有可用的动态内存空间时，就会很难找到这两个连续页框，因为空闲空间可能存在大量碎片。因此，在80x86体系结构中，在编译时可以设置，以使内核堆栈和线程描述符跨越一个单独的页框。</p>

<p class="center"><img src="/linux-kernel-architecture/images/thread_info.png" alt="system" style="max-width:600px" /></p>

<p class="center">进程堆栈</p>

<p>esp寄存器是CPU栈指针，用来存放栈顶单元的地址。在80x86系统中，栈起始于末端，并朝这个内存区开始的方向增长。从用户态刚切换到内核态以后，进程的内核栈总是空的。因此esp寄存器指向这个栈的顶端。一旦数据写入堆栈，esp的值就递减，因为thread_info结构是52个字节长，因此内核栈能扩展到8140个字节。</p>

<p>current是当前进程指针。</p>

<p>下面C语言大概描述了线程描述符和内核栈：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">union</span> <span class="n">thread_union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">thread_info</span> <span class="n">thread_info</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack</span><span class="p">[</span><span class="mi">2048</span><span class="p">];</span>
<span class="p">};</span></code></pre></div>

<h3 id="section-2">标识当前进程</h3>

<p>thread_info结构与内核态堆栈之间的紧密结合提供的主要好处是内核很容易从esp寄存器的值获得当前在CPU上正在运行的进程thread_info结构地址。如果thread_info的结构长度是8K，则内核屏蔽掉esp的低13位有效位就可以获得thread_info结构的基地址；如果thread_info结构长度是4K，内核只需要屏蔽esp的低12位有效位。</p>

<p>进程最常用的是进程描述符的地址而不是thread_info结构的地址。为了获得当前在CPU上运行的描述符指针，内核调用current<sup id="fnref:3"><a href="#fn:3" class="footnote">4</a></sup>宏获取。current宏进程作为进程描述符字段的前缀出现在内核代码中，例如<code>current-&gt;pid</code>返回在CPU上正在执行的进程PID。</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>尽管从技术上说，这32位仅仅是一个逻辑地址的偏移量部分，但它们与线性地址相一致。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>PID_MAX_DEFAULT-1。 <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:namespace">
      <p>可以看<a href="/linux-kernel-architecture/2014/04/02/process-type-and-namespace/">《进程类型和命名空间》</a>。 <a href="#fnref:namespace" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>current_thread_info()-&gt;task。 <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#标识进程">#标识进程</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#描述符">#描述符</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#task_struct">#task_struct</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#页框">#页框</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#命名空间">#命名空间</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#全局ID">#全局ID</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#局部ID">#局部ID</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/process-type-and-namespace/" class="pre">&lt; 进程类型和命名空间</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/process-list/" class="next">进程链表 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments process进程_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章标识进程写于2014年04月04日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
