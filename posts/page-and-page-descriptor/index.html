<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>页及其描述符|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 内存组织..." name="description"/>
  <meta content="内存,UMA,NUMA,页描述符,page," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/page-and-page-descriptor/" />
  <meta property="og:title" content="页及其描述符" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 内存组织..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">daf94cf87</a></li>
  <!--
  I love bettylwx
    -->
</ul>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">页及其描述符</div>

  <div class="content 内存管理_content_css">
    <p>内存管理是内核中最为复杂的一部分，我之前想要跳过这里了解后面的内容，而且我确实看书看到比较后面，但最后还是得回来看内存管理这一部分，因为不仅仅内存需要进行内存管理，进程调度等算法也涉及到内存管理，所以没办法还得看。内存管理涵盖了许多领域，是一个旷日持久的学习过程。这一部分可能会涉及很多的代码，但我自己不一定能够全部理解。</p>

<p>内存管理涉及的领域有：</p>

<ol>
  <li>内存中的物理内存页的管理。</li>
  <li>分配大块内存的伙伴系统。</li>
  <li>分配较小内存的slab、slub和slob分配器。</li>
  <li>分配非连续内存块的vmalloc机制。</li>
  <li>进程的地址空间。</li>
</ol>

<p>之前的笔记里有<a href="/linux-kernel-architecture/posts/task-size/">进程的地址空间</a>和<a href="/linux-kernel-architecture/posts/mm-management/">内存管理</a>的基本知识，需要了解，如果对于细节不感兴趣的话，我觉得可以跳过。不过也没有什么可看的了，基本的内存和进程知识前面的笔记也说的很详细了。</p>

<p>我们知道，Linux内核一般将处理器的虚拟地址空间划分为两个部分，底部比较大的部分用于用户进程，顶部则用于内核。虽然上下文切换期间会修改底部的用户进程部分，但虚拟地址空间的内核部分总是保持不变。地址空间在用户进程和内核之间划分的典型比例为3:1。给出4GB的虚拟地址空间，3GB将用于用户空间而1GB而用于内核。</p>

<p>可用的物理内存将映射到内核的地址空间中。访问内存时，如果所用的虚拟地址与内核区域的起始地址之间的偏移量不超过可用物理内存的长度，那么该虚拟地址会自动关联到物理页帧。不过，还有一个问题，虚拟地址空间的内核部分必然小于CPU理论地址空间的最大长度。如果物理内存比可以映射到内核地址空间的数量要多，那么内核必须借助高端内存方法来管理多的内存。普通的32位80x86系统上，可以直接接管的物理内存数量不超过896MB，超过最大4GB的内存只能通过高端内存寻址<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。在64位计算机上，由于可用的地址空间非常巨大，因此不需要高端内存模式<sup id="fnref:3"><a href="#fn:3" class="footnote">2</a></sup>。</p>

<p>一般情况下，有两种计算机，分别为UMA和NUMA计算机来管理物理内存，虽然之前的笔记已经提到过，这里再拿出来。</p>

<p class="center"><img src="/linux-kernel-architecture/images/numa.png" alt="numa" style="max-width:600px" /></p>

<p class="center">UMA和NUMA</p>

<p>（1）：UMA计算机（<em>一致内存访问，uniform memory access</em>）将可用内存以连续方式组织起来，系统中的每个处理器访问各个内存都是同样的块。</p>

<p>（2）：NUMA计算机（<em>非一致内存访问，non uniform memory access</em>）总是多处理器计算机。系统的各个CPU都有本地内存，可支持特别快的访问，各个处理器之间通过总线连接起来。</p>

<p>在UMA系统上，值使用一个NUMA节点来管理系统内存，所以首先考虑NUMA系统，这样UMA系统就比较好理解了。两种类型的计算机的混合也是可能的，其中使用不连续的内存。在UMA系统中，内存不是连续的，而会有比较大的洞。在这里应用NUMA体系结构的原理会有帮助，可以使内核的内存访问更简单。</p>

<p>实际上内核会区分3种内存管理的配置选项，FLATMEM、DISCOUNTIGMEM和SPARSEMEM<sup id="fnref:2"><a href="#fn:2" class="footnote">3</a></sup>。真正的NUMA会设置配置选项CONFIG_NUMA，相关的内存管理代码也有很大的不同。</p>

<h3 id="section">页描述符</h3>

<p>内核必须记录每个页框当前的状态，例如，内核必须能够区分哪些页框包含的是属于进程的页而哪些页框包含的是内核代码或内核数据。类似的，内核还必须能够确定动态内存中的页框是否空闲。如果动态内存中的页框不包含有用的数据，那么这个页框就是空的。</p>

<p>页框的状态信息保存在一个类型为<em>page</em>的页描述符中，虽然在前面的内存寻址里的笔记里有列出，但代码再列出来如下，记录一些详细的字段。</p>

<h4 id="includelinuxmmtypesh">&lt;include/linux/mm_types.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">page</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
    <span class="n">atomic_t</span> <span class="n">_count</span><span class="p">;</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="cm">/* Count of ptes mapped in mms,
         * to show when page is mapped
         * &amp; limit reverse map searches.
         */</span>
        <span class="n">atomic_t</span> <span class="n">_mapcount</span><span class="p">;</span>
        <span class="cm">/* SLUB */</span>
        <span class="k">struct</span> <span class="p">{</span>
            <span class="n">u16</span> <span class="n">inuse</span><span class="p">;</span>
            <span class="n">u16</span> <span class="n">objects</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">};</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="p">{</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">private</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
        <span class="p">};</span>
<span class="cp">#if USE_SPLIT_PTLOCKS
</span>        <span class="n">spinlock_t</span> <span class="n">ptl</span><span class="p">;</span>
<span class="cp">#endif
</span>        <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">slab</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">first_page</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">union</span> <span class="p">{</span>
        <span class="n">pgoff_t</span> <span class="n">index</span><span class="p">;</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">freelist</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">lru</span><span class="p">;</span>
<span class="cp">#if defined(WANT_PAGE_VIRTUAL)
</span>    <span class="kt">void</span> <span class="o">*</span><span class="k">virtual</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_WANT_PAGE_DEBUG_FLAGS
</span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">debug_flags</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cp">#ifdef CONFIG_KMEMCHECK
</span>    <span class="kt">void</span> <span class="o">*</span><span class="n">shadow</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">};</span></code></pre></div>

<p>其中各个字段的意义如下：</p>

<table class="table_center">
  <thead>
    <tr>
      <th>字段名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>flags</td>
      <td>一组标志，对页框所在的管理区进行编号</td>
    </tr>
    <tr>
      <td>_count</td>
      <td>页框的引用计数器</td>
    </tr>
    <tr>
      <td>_mapcount</td>
      <td>页框中的页表项数目，如果没有则为-1</td>
    </tr>
    <tr>
      <td>private</td>
      <td>可用于正在使用页的内核成分</td>
    </tr>
    <tr>
      <td>mapping</td>
      <td>当页被插入页高速缓存中的时候使用</td>
    </tr>
    <tr>
      <td>index</td>
      <td>作为不同的含义被几种内核成分使用</td>
    </tr>
    <tr>
      <td>lru</td>
      <td>包含页的最近最少使用（LRU）双向链表的指针</td>
    </tr>
  </tbody>
</table>

<p>其中重要的两个字段为<em>_count</em>和<em>flags</em>。<em>_count</em>是页的引用计数器，如果字段为-1，则相应的页框空闲，并可以被分配给任意一个进程甚至内核本身，如果该字段大于或等于-，则说明页框被分配给了一个或多个进程，用于存放一些内核数据结构。<em>flags</em>包含多大32个用来描述页框标志的状态，对于每个PG_xxx标志内核都定义了操作其值的一些宏。</p>

<table class="table_center">
  <thead>
    <tr>
      <th>标志名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>PG_locked</td>
      <td>页被锁定</td>
    </tr>
    <tr>
      <td>PG_error</td>
      <td>在传输过程中发生I/O错误</td>
    </tr>
    <tr>
      <td>PG_referenced</td>
      <td>刚刚访问过的页</td>
    </tr>
    <tr>
      <td>PG_uptodate</td>
      <td>在完成读操作后置位</td>
    </tr>
    <tr>
      <td>PG_dirty</td>
      <td>页已经被修改</td>
    </tr>
    <tr>
      <td>PG_lru</td>
      <td>页在活动或非活动页链表中</td>
    </tr>
    <tr>
      <td>PG_active</td>
      <td>页在活动页链表中</td>
    </tr>
    <tr>
      <td>PG_slab</td>
      <td>包含在slab中的页框</td>
    </tr>
    <tr>
      <td>PG_highmem</td>
      <td>页框属于ZONE_HIGHMEM管理区</td>
    </tr>
    <tr>
      <td>PG_checked</td>
      <td>由一些文件系统使用的标识</td>
    </tr>
    <tr>
      <td>PG_arch_1</td>
      <td>在80x86体系结构上没有使用</td>
    </tr>
    <tr>
      <td>PG_reserved</td>
      <td>页框留给内核代码或没有使用</td>
    </tr>
    <tr>
      <td>PG_private</td>
      <td>页描述符的private字段存放了有意义的数据</td>
    </tr>
    <tr>
      <td>PG_writeback</td>
      <td>页正在使用writepage方法将页写到磁盘上</td>
    </tr>
    <tr>
      <td>PG_nosave</td>
      <td>系统挂起/唤醒时使用</td>
    </tr>
    <tr>
      <td>PG_compound</td>
      <td>通过扩展分页机制处理页框</td>
    </tr>
    <tr>
      <td>PG_swapcache</td>
      <td>页属于对换高速缓存</td>
    </tr>
    <tr>
      <td>PG_mappedtodisk</td>
      <td>页框中的所有数据对应于磁盘上分配的块</td>
    </tr>
    <tr>
      <td>PG_reclaim</td>
      <td>为回收内存对页已经做了写入磁盘标记</td>
    </tr>
    <tr>
      <td>PG_nosave_free</td>
      <td>系统挂起/恢复时使用</td>
    </tr>
  </tbody>
</table>

<p>所有的页描述符存放在<em>mem_map</em>数组中。因为每个描述符的长度为32字节，所以<em>mem_map</em>所需要的空间略小于整个RAM的1%。<em>virt_to_page(addr)</em>宏产生线性地址<em>addr</em>对应的页描述符地址。</p>

<h4 id="includelinuxmmzoneh">&lt;include/linux/mmzone.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#ifndef CONFIG_DISCONTIGMEM
</span><span class="k">extern</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">mem_map</span><span class="p">;</span>
<span class="cp">#endif</span></code></pre></div>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>具体可以参考内存寻址里的PAE机制。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>只有内核自身使用高端内存页的时候才会有问题，在内核使用高端内存页之前，必须使用kmap和kunmap函数将其映射到内核虚拟地址中，对普通内存页这是不必的。对用户空间进程来说，是否是高端内存页没有任何差别，因为用户进程总是通过页表访问内存。 <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>实际上这种方式不太稳定，但有一些性能优化。 <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#内存">#内存</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#UMA">#UMA</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#NUMA">#NUMA</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#页描述符">#页描述符</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#page">#page</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/linux-paging/" class="pre">&lt; Linux中的分页</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/physical-memory/" class="next">物理内存布局 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 内存管理_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章页及其描述符写于2014年04月17日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
