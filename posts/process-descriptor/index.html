<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>进程描述符|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 进程描述符..." name="description"/>
  <meta content="进程描述符,进程状态,task_struct,资源限制," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/process-descriptor/" />
  <meta property="og:title" content="进程描述符" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 进程描述符..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">Home</a></li>
  <li><a href="/archive/">Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/">Kernel</a></li>
</ul>

</div>

<div class="container">

<div class="main clearfix">
  <div class="title">进程描述符</div>

  <div class="content process进程_content_css">
    <p>为了进程管理，内核必须对每个进程所做的事情进行清楚的描述。比如内核需要知道进程的优先级，进程当前的状态，在挂起和恢复进程的时候，需要对进程进行相应的操作。进程描述符还描述了进程使用的地址空间，访问的文件等等，这些都是进程描述符的作用。</p>

<p>进程描述符都是<em>task_struct</em>类型的结构，它的字段包含了与一个进程相关的所有信息。因为进程描述符中存放了那么多信息，所以它是非常复杂的，它不仅仅包括了很多进程属性的字段，还有一些字段包括了指向其他数据结构的指针，如下图：</p>

<p class="center"><img src="/linux-kernel-architecture/images/task_struct.png" alt="task struct" style="max-width:600px" /></p>

<p class="center">进程描述符结构</p>

<p>进程有很多状态，从代码中我们可以看：</p>

<pre><code>- volatile long state;
  /* -1 unrunnable, 0 runnable, &gt;0 stopped */
  represents the state of the process.
  Authorized states are 
  TASK_RUNNING, TASK_INTERRUPTIBLE, TASK_UNINTERRUPTIBLE,
  TASK_STOPPED, TASK_TRACED
  TASK_ZOMBIE and TASK_DEAD
</code></pre>

<p>可运行状态：</p>

<ul>
  <li>TASK_RUNNING: 要么在CPU上执行，要么准备执行。</li>
  <li>TASK_INTERRUPTIBLE: 进程被挂起（睡眠），直到某个为真的条件触发，产生一个硬件中断，释放进程正等待的系统资源，或传递一个信号都可以唤醒进程。</li>
  <li>TASK_UNINTERRUPTIBLE: 不可中断的等待状态，与把信号传递给睡眠进程不能改变它的状态<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。</li>
  <li>TASK_STOPPED: 进程的执行被暂停，当收到SIGSTOP、SIGTSTP、SIGTTIN或SIGTTOU信号后，进入暂停状态。</li>
  <li>TASK_TRACED: 跟踪状态，进程的执行由debugger程序暂停。</li>
  <li>TASK_ZOMBIE<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>: 进程执行被终止，但是父进程还没有发布wait4或waitpid系统调用返回有关死亡进程的信息。</li>
  <li>TASK_DEAD<sup id="fnref:2:1"><a href="#fn:2" class="footnote">2</a></sup>: 僵死撤销状态。</li>
</ul>

<p>task_struct可以看作是进程的一个实例，我并不想列出所有的代码，实际上理解进程也无需了解代码，毕竟笔记的目的只是为了了解，而不是做内核开发。但有时候特定的代码还是没办法完全忽略的。</p>

<h4 id="includelinuxschedh">&lt;include/linux/sched.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cm">/*
 * 虽然有很多地方我们暂时还不是很了解，但是
 * 以后会有很多机会重新回到这个数据结构，毕
 * 竟这是内核中非常重要的数据结构。
 * 进程管理和内存管理都是内核中非常重要的知
 * 识，需要长期的理解和消化。
 */</span>
<span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
  <span class="c1">// -1表示不可运行，0表示可运行，大于0表示停止
</span>  <span class="k">volatile</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">stack</span><span class="p">;</span>
  <span class="n">atomic_t</span> <span class="n">usage</span><span class="p">;</span>
  <span class="c1">// 每进程标志，上下文定义
</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">ptrace</span><span class="p">;</span>

  <span class="c1">// 大内核锁的深度
</span>  <span class="kt">int</span> <span class="n">lock_depth</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP
#ifdef __ARCH_WANT_UNLOCKED_CTXSW
</span>  <span class="kt">int</span> <span class="n">oncpu</span><span class="p">;</span>
<span class="cp">#endif
#endif
</span>  <span class="c1">// 优先级
</span>  <span class="kt">int</span> <span class="n">prio</span><span class="p">,</span> <span class="n">static_prio</span><span class="p">,</span> <span class="n">normal_prio</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rt_priority</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">sched_class</span> <span class="o">*</span><span class="n">sched_class</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sched_entity</span> <span class="n">se</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sched_rt_entity</span> <span class="n">rt</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_PREEMPT_NOTIFIERS
</span>  <span class="cm">/* 同步的通知者 */</span>
  <span class="k">struct</span> <span class="n">hlist_head</span> <span class="n">preempt_notifiers</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fpu_counter</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_BLK_DEV_IO_TRACE
</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">btrace_seq</span><span class="p">;</span>
<span class="cp">#endif
</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">policy</span><span class="p">;</span>
  <span class="n">cpumask_t</span> <span class="n">cpus_allowed</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_TREE_PREEMPT_RCU
</span>  <span class="kt">int</span> <span class="n">rcu_read_lock_nesting</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">rcu_read_unlock_special</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">rcu_node</span> <span class="o">*</span><span class="n">rcu_blocked_node</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">rcu_node_entry</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cp">#if defined(CONFIG_SCHEDSTATS) \
  || defined(CONFIG_TASK_DELAY_ACCT)
</span>  <span class="k">struct</span> <span class="n">sched_info</span> <span class="n">sched_info</span><span class="p">;</span>
<span class="cp">#endif
</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">tasks</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">plist_node</span> <span class="n">pushable_tasks</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">,</span> <span class="o">*</span><span class="n">active_mm</span><span class="p">;</span>

<span class="cm">/* 进程状态 */</span>
  <span class="kt">int</span> <span class="n">exit_state</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">exit_code</span><span class="p">,</span> <span class="n">exit_signal</span><span class="p">;</span>
  <span class="c1">// 在父进程终止时发送的信号
</span>  <span class="kt">int</span> <span class="n">pdeath_signal</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">personality</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">did_exec</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">in_execve</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">in_iowait</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>


  <span class="kt">unsigned</span> <span class="n">sched_reset_on_fork</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

  <span class="c1">// pid和组id
</span>  <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>
  <span class="n">pid_t</span> <span class="n">tgid</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CC_STACKPROTECTOR
</span>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_canary</span><span class="p">;</span>
<span class="cp">#endif
</span>
  <span class="cm">/* 
   * 分别指向原父进程
   * 最年轻的子进程
   * 年幼的兄弟进程
   * 年长的兄弟进程的指针
   */</span>
  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">real_parent</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">children</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">sibling</span><span class="p">;</span>
  <span class="c1">// 线程组的组长
</span>  <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">group_leader</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">ptraced</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">ptrace_entry</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">bts_context</span> <span class="o">*</span><span class="n">bts</span><span class="p">;</span>

  <span class="cm">/* PID/PID散列表的关系 */</span>
  <span class="k">struct</span> <span class="n">pid_link</span> <span class="n">pids</span><span class="p">[</span><span class="n">PIDTYPE_MAX</span><span class="p">];</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">thread_group</span><span class="p">;</span>

  <span class="c1">// 用于vfork()
</span>  <span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">vfork_done</span><span class="p">;</span>
  <span class="c1">// CLONE_CHILD_SETTID
</span>  <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">set_child_tid</span><span class="p">;</span>
  <span class="c1">// CLONE_CHILD_CLEARTID
</span>  <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">clear_child_tid</span><span class="p">;</span>

  <span class="n">cputime_t</span> <span class="n">utime</span><span class="p">,</span> <span class="n">stime</span><span class="p">,</span> <span class="n">utimescaled</span><span class="p">,</span> <span class="n">stimescaled</span><span class="p">;</span>
  <span class="n">cputime_t</span> <span class="n">gtime</span><span class="p">;</span>
  <span class="n">cputime_t</span> <span class="n">prev_utime</span><span class="p">,</span> <span class="n">prev_stime</span><span class="p">;</span>
  <span class="c1">// 上下文切换计数器
</span>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nvcsw</span><span class="p">,</span> <span class="n">nivcsw</span><span class="p">;</span>
  <span class="c1">// 单调时间
</span>  <span class="k">struct</span> <span class="n">timespec</span> <span class="n">start_time</span><span class="p">;</span>
  <span class="c1">// 启动以来的时间
</span>  <span class="k">struct</span> <span class="n">timespec</span> <span class="n">real_start_time</span><span class="p">;</span>
  <span class="c1">// 内存管理器失效和页交换信息
</span>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_flt</span><span class="p">,</span> <span class="n">maj_flt</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">cputime_expires</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">cpu_timers</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="cm">/* 进程身份 */</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">real_cred</span><span class="p">;</span>
  <span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">mutex</span> <span class="n">cred_guard_mutex</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">replacement_session_keyring</span><span class="p">;</span>

  <span class="kt">char</span> <span class="n">comm</span><span class="p">[</span><span class="n">TASK_COMM_LEN</span><span class="p">];</span>

<span class="cm">/* 文件系统信息 */</span>
  <span class="kt">int</span> <span class="n">link_count</span><span class="p">,</span> <span class="n">total_link_count</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SYSVIPC
</span><span class="cm">/* ipc相关信息 */</span>
  <span class="k">struct</span> <span class="n">sysv_sem</span> <span class="n">sysvsem</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_DETECT_HUNG_TASK
</span>  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_switch_count</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="cm">/* 当前进程特定于CPU的状态信息 */</span>
  <span class="k">struct</span> <span class="n">thread_struct</span> <span class="kr">thread</span><span class="p">;</span>
<span class="cm">/* 文件系统信息 */</span>
  <span class="k">struct</span> <span class="n">fs_struct</span> <span class="o">*</span><span class="n">fs</span><span class="p">;</span>
<span class="cm">/* 打开文件信息 */</span>
  <span class="k">struct</span> <span class="n">files_struct</span> <span class="o">*</span><span class="n">files</span><span class="p">;</span>
<span class="cm">/* 命名空间 */</span>
  <span class="k">struct</span> <span class="n">nsproxy</span> <span class="o">*</span><span class="n">nsproxy</span><span class="p">;</span>
<span class="cm">/* 信号处理程序 */</span>
  <span class="k">struct</span> <span class="n">signal_struct</span> <span class="o">*</span><span class="n">signal</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sighand_struct</span> <span class="o">*</span><span class="n">sighand</span><span class="p">;</span>

  <span class="n">sigset_t</span> <span class="n">blocked</span><span class="p">,</span> <span class="n">real_blocked</span><span class="p">;</span>
  <span class="n">sigset_t</span> <span class="n">saved_sigmask</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sigpending</span> <span class="n">pending</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sas_ss_sp</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">sas_ss_size</span><span class="p">;</span>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">notifier</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">priv</span><span class="p">);</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">notifier_data</span><span class="p">;</span>
  <span class="n">sigset_t</span> <span class="o">*</span><span class="n">notifier_mask</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">audit_context</span> <span class="o">*</span><span class="n">audit_context</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_AUDITSYSCALL
</span>  <span class="n">uid_t</span> <span class="n">loginuid</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sessionid</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="n">seccomp_t</span> <span class="n">seccomp</span><span class="p">;</span>

<span class="cm">/* 进程组的信息 */</span>
    <span class="n">u32</span> <span class="n">parent_exec_id</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">self_exec_id</span><span class="p">;</span>
  <span class="c1">// 保护mm，files等信息的自旋锁
</span>  <span class="n">spinlock_t</span> <span class="n">alloc_lock</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_GENERIC_HARDIRQS
</span>  <span class="cm">/* IRQ处理进程 */</span>
  <span class="k">struct</span> <span class="n">irqaction</span> <span class="o">*</span><span class="n">irqaction</span><span class="p">;</span>
<span class="cp">#endif
</span>
  <span class="n">spinlock_t</span> <span class="n">pi_lock</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_RT_MUTEXES
</span>  <span class="k">struct</span> <span class="n">plist_head</span> <span class="n">pi_waiters</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">rt_mutex_waiter</span> <span class="o">*</span><span class="n">pi_blocked_on</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cp">#ifdef CONFIG_DEBUG_MUTEXES
</span>  <span class="k">struct</span> <span class="n">mutex_waiter</span> <span class="o">*</span><span class="n">blocked_on</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_TRACE_IRQFLAGS
</span>  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">irq_events</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">hardirqs_enabled</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hardirq_enable_ip</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hardirq_enable_event</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hardirq_disable_ip</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hardirq_disable_event</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">softirqs_enabled</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">softirq_disable_ip</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">softirq_disable_event</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">softirq_enable_ip</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">softirq_enable_event</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">hardirq_context</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">softirq_context</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_LOCKDEP
# define MAX_LOCK_DEPTH 48UL
</span>  <span class="n">u64</span> <span class="n">curr_chain_key</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">lockdep_depth</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lockdep_recursion</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">held_lock</span> <span class="n">held_locks</span><span class="p">[</span><span class="n">MAX_LOCK_DEPTH</span><span class="p">];</span>
  <span class="n">gfp_t</span> <span class="n">lockdep_reclaim_gfp</span><span class="p">;</span>
<span class="cp">#endif
</span>
<span class="cm">/* 日志文件系统信息 */</span>
  <span class="kt">void</span> <span class="o">*</span><span class="n">journal_info</span><span class="p">;</span>

<span class="cm">/* 快设备信息 */</span>
  <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_list</span><span class="p">,</span> <span class="o">**</span><span class="n">bio_tail</span><span class="p">;</span>

<span class="cm">/* 虚拟内存状态 */</span>
  <span class="k">struct</span> <span class="n">reclaim_state</span> <span class="o">*</span><span class="n">reclaim_state</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">backing_dev_info</span><span class="p">;</span>

  <span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">io_context</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptrace_message</span><span class="p">;</span>
  <span class="n">siginfo_t</span> <span class="o">*</span><span class="n">last_siginfo</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">task_io_accounting</span> <span class="n">ioac</span><span class="p">;</span>
<span class="cp">#if defined(CONFIG_TASK_XACCT)
</span>  <span class="n">u64</span> <span class="n">acct_rss_mem1</span><span class="p">;</span>
  <span class="n">u64</span> <span class="n">acct_vm_mem1</span><span class="p">;</span>
  <span class="n">cputime_t</span> <span class="n">acct_timexpd</span><span class="p">;</span> <span class="cm">/* stime + utime since last update */</span>
<span class="cp">#endif
#ifdef CONFIG_CPUSETS
</span>  <span class="n">nodemask_t</span> <span class="n">mems_allowed</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">cpuset_mem_spread_rotor</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_CGROUPS
</span>  <span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">cgroups</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">cg_list</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_FUTEX
</span>  <span class="k">struct</span> <span class="n">robust_list_head</span> <span class="n">__user</span> <span class="o">*</span><span class="n">robust_list</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_COMPAT
</span>  <span class="k">struct</span> <span class="n">compat_robust_list_head</span> <span class="n">__user</span> <span class="o">*</span><span class="n">compat_robust_list</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">pi_state_list</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">futex_pi_state</span> <span class="o">*</span><span class="n">pi_state_cache</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_PERF_EVENTS
</span>  <span class="k">struct</span> <span class="n">perf_event_context</span> <span class="o">*</span><span class="n">perf_event_ctxp</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">mutex</span> <span class="n">perf_event_mutex</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">list_head</span> <span class="n">perf_event_list</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_NUMA
</span>  <span class="k">struct</span> <span class="n">mempolicy</span> <span class="o">*</span><span class="n">mempolicy</span><span class="p">;</span>
  <span class="kt">short</span> <span class="n">il_next</span><span class="p">;</span>
<span class="cp">#endif
</span>  <span class="n">atomic_t</span> <span class="n">fs_excl</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu</span><span class="p">;</span>

  <span class="o">//</span> <span class="p">...</span></code></pre></div>

<h3 id="section">进程资源限制</h3>

<p>每个进程都有一组相关的资源限制（<em>resource limit</em>），限制指定了进程能使用的系统资源数量。这些资源限制避免用户过分使用系统资源（CPU，磁盘空间等）。堆当前进程的资源限制存放在<em>current-&gt;signal-&gt;rlim</em>字段<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>，即进程描述符的一个字段。这个字段类型为rlimit结构的数组，每个资源限制对应一个元素：</p>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">rlimit</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rlim_cur</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">rlim_max</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>资源限制包括：</p>

<table>
  <thead>
    <tr>
      <th>字段名</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>RLIMIT_AS</td>
      <td>进程地址空间的最大数，以字节为单位，当进程使用malloc或相关函数的时候会检查这个值</td>
    </tr>
    <tr>
      <td>RLIMIT_CORE</td>
      <td>内存信息转储文件的大小，当一个进程异常终止时，内核在进程的当前目录下创建内存信息转储文件之前检查这个值</td>
    </tr>
    <tr>
      <td>RLIMIT_CPU</td>
      <td>进程使用CPU的最长时间，以秒为单位</td>
    </tr>
    <tr>
      <td>RLIMIT_DATA</td>
      <td>堆大小的最大值</td>
    </tr>
    <tr>
      <td>RLIMIT_FSIZE</td>
      <td>文件大小的最大值，如果进程把一个文件的大小扩充到这个值，内核就给这个进程发送SIGXFSZ信号</td>
    </tr>
    <tr>
      <td>RLIMIT_LOCKS</td>
      <td>文件锁数量的最大值</td>
    </tr>
    <tr>
      <td>RLIMIT_MEMLOCK</td>
      <td>非交换内存的最大值，当进程试图通过mlock或者mlockall锁住页框时，会检查这个值</td>
    </tr>
    <tr>
      <td>RLIMIT_MSGOUEUE</td>
      <td>POSIX消息队列中的最大字节数</td>
    </tr>
    <tr>
      <td>RLIMIT_NOFILE</td>
      <td>打开文件描述符的最大数，打开一个文件或复制一个文件时会检查这个值</td>
    </tr>
    <tr>
      <td>RLIMIT_NPROC</td>
      <td>用户能拥有的进程最大数</td>
    </tr>
    <tr>
      <td>RLIMIT_RSS</td>
      <td>进程锁拥有的页框最大数</td>
    </tr>
    <tr>
      <td>RLIMIT_SIGPENDING</td>
      <td>进程挂起信号的最大数</td>
    </tr>
    <tr>
      <td>RLIMIT_STACK</td>
      <td>栈大小的最大值，内核在扩充进程的用户态堆栈之前检查这个值</td>
    </tr>
  </tbody>
</table>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>这种状态很少用到，但在一些特定的情况下，这种状态是很有用的。例如，当进程打开一个设备文件，其相应的设备驱动程序开始探测相应的硬件设备时会用到这种状态。探测完成之前，设备驱动程序不能被中断。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>貌似有的版本叫EXIT_ZOMBIE和EXIT_DEAD。 <a href="#fnref:2" class="reversefootnote">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:3">
      <p>current可以获取当前进程。 <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#进程描述符">#进程描述符</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#进程状态">#进程状态</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#task_struct">#task_struct</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#资源限制">#资源限制</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/process/" class="pre">&lt; 进程、轻量级进程和线程</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/process-priority/" class="next">进程优先级 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments process进程_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章进程描述符写于2014年03月30日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
