<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>组织进程|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 组织进程..." name="description"/>
  <meta content="等待队列,互斥进程," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/process-waiting-link-list/" />
  <meta property="og:title" content="组织进程" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 组织进程..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">daf94cf87</a></li>
  <!--
  I love bettylwx
    -->
</ul>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">组织进程</div>

  <div class="content 进程_content_css">
    <p>运行队列链表把处于TASK_RUNNING状态的所有进程组织在一起，当要求把其他状态的进程分组时，不同的状态要求不同的处理，Linux选择了下列方式之。</p>

<p>没有为处于TASK_STOPPED、EXIT_ZOMBIE或EXIT_DEAD状态的进程建立专门的链表。由于对处理暂停、僵死、死亡状态的进程访问比较简单，或者通过PID，或者通过特定父进程的子进程链表，所以不必堆这三种状态进行分组。</p>

<p>根据不同的特殊事件把处于TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE状态的进程细分为许多类，每一类都对应某个特殊的事件。在这种情况下，进程状态提供的信息满足不了快速检索进程的需要，所以必须引入另外的进程链表，这些链表被称作等待队列。</p>

<h3 id="section">等待队列</h3>

<p>等待队列在内核中有很多用途，尤其用在中断处理、进程同步以及定时。这里并不详细解释，但进程必须经常等待某些事件的发生，例如等待I/O操作中止，等待释放系统资源，或者等待时间经过固定的间隔。等待队列实现了在事件上的条件等待：希望等待特定事件的进程把自己放进和式的等待队列，并放弃控制权。因为，等待队列表示一组睡眠的进程，当某个条件触发，内核会唤醒这些等待队列。</p>

<p>等待队列由双向链表实现<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。元素包括指向进程描述符的指针，每个等待队列都有一个等待队列头（<em>wait queue head</em>），等待队列头是一个类型为<em>wait_queue_head_t</em>的数据结构：</p>

<h4 id="includelinuxwaith">&lt;include/linux/wait.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">__wait_queue_head</span> <span class="p">{</span>
    <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">task_list</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">__wait_queue_head</span> <span class="n">wait_queue_head_t</span><span class="p">;</span></code></pre></div>

<p>因为等待队列是由中断处理程序和主要内核函数修改的，因此必须对其双向链表进行保护以免对其进行同时访问，因为同时访问会导致不可预测的后果。同步是通过等待队列头中的<em>lock</em>自旋锁实现的。<em>task_list</em>字段是等待进程链表的头。</p>

<p>等待进程链表中的元素类型为wait_queue_t，定义如下：</p>

<h4 id="includelinuxwaith-1">&lt;include/linux/wait.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">__wait_queue</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span> <span class="n">task</span><span class="p">;</span>
    <span class="n">wait_queue_func_t</span> <span class="n">func</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">task_list</span><span class="p">;</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">__wait_queue</span> <span class="n">wait_queue_t</span><span class="p">;</span></code></pre></div>

<p>等待队列链表中的每个元素代表一个睡眠的进程，该进程等待某一事件的发生，它的描述符地址存放在<em>task</em>字段中，<em>task_list</em>字段中包含的是指针，由这个指针把一个元素链接到等待相同事件的进程链表中。</p>

<p>有时候，唤醒等待队列中的睡眠的进程有时并不方便，例如，如果两个或多个进程在等待互斥访问某一要释放的资源，仅仅唤醒一个进程才有意义。这个进程占有资源，而其他进程继续睡眠。否则唤醒多个进程只为了竞争一个资源，而这个资源只有一个进程能访问，结果其他进程必须再回到睡眠状态。</p>

<p>因此，有两种睡眠进程：互斥进程<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>由内核有选择地唤醒，而非互斥进程<sup id="fnref:2:1"><a href="#fn:2" class="footnote">2</a></sup>总是由内核在事件发生时唤醒。等待访问临界资源的进程就是互斥进程的典型例子。</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>双向链表真是内核里无所不在的数据结构，树也是。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>wait_queue_t结构提里flag字段为1为互斥进程，为0则为非互斥进程。 <a href="#fnref:2" class="reversefootnote">&#8617;</a> <a href="#fnref:2:1" class="reversefootnote">&#8617;<sup>2</sup></a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#等待队列">#等待队列</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#互斥进程">#互斥进程</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/process-relationship/" class="pre">&lt; 进程之间的关系</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/the-kernel-thread/" class="next">内核线程 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 进程_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章组织进程写于2014年04月10日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
