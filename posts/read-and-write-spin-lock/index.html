<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>读/写自旋锁|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 读/写自旋锁..." name="description"/>
  <meta content="自旋锁," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/read-and-write-spin-lock/" />
  <meta property="og:title" content="读/写自旋锁" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 读/写自旋锁..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/" class="glyphicon glyphicon-inbox"> Home</a></li>
  <li><a href="/archive" class="glyphicon glyphicon-floppy-disk"> Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/" class="glyphicon glyphicon-book"> Kernel</a></li>
  <li><a href="/about" class="glyphicon glyphicon-record"> About</a></li>
</ul>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">读/写自旋锁</div>

  <div class="content 内核同步_content_css">
    <p>读/写自旋锁的引入是为了增加内核的并发能力，只要没有内核控制路径对数据结构进行修改，读/写自旋锁就允许多个内核控制路径同时读一个数据结构，如果一个内核控制路径想对这个数据结构进行操作，那么它必须首先获取读/写自旋锁的写锁，写锁的授权独占访问这个资源。当然，允许对数据结构的并发可以提高系统性能。</p>

<p>每个读/写自旋锁都是一个<em>rwlock_t</em>结构，代码如下：</p>

<h4 id="includelinuxspinlocktypesh">&lt;include/linux/spinlock_types.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">raw_rwlock_t</span> <span class="n">raw_lock</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_GENERIC_LOCKBREAK
</span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">break_lock</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_DEBUG_SPINLOCK
</span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">magic</span><span class="p">,</span> <span class="n">owner_cpu</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
<span class="cp">#endif
#ifdef CONFIG_DEBUG_LOCK_ALLOC
</span>    <span class="k">struct</span> <span class="n">lockdep_map</span> <span class="n">dep_map</span><span class="p">;</span>
<span class="cp">#endif
</span><span class="p">}</span> <span class="n">rwlock_t</span><span class="p">;</span></code></pre></div>

<p>自旋锁的实现是体系结构相关的，所以我们可以看x86里面自旋锁的结构，从上面的结构体中我们可以看到有一个<em>raw_rwlock_t</em>的结构体对象<em>raw_lock</em>，我们可以看看在arch/x86中的<em>raw_rwlock_t</em>对象。</p>

<h4 id="archx86includeasmspinlocktypesh">&lt;arch/x86/include/asm/spinlock_types.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">}</span> <span class="n">raw_rwlock_t</span><span class="p">;</span></code></pre></div>

<p>我们可以看到，这个结构体里就就只有一个<em>lock</em>字段。</p>

<p><em>lock</em>字段是一个32位的字段，分为两个不同的部分：</p>

<ol>
  <li>24位计数器，表示对受保护的数据结构并发地进行读操作和内核控制路径的数目，这个计数器的二进制补码存放在这个字段的0～23位。</li>
  <li>『未锁』标志字段，当没有内核控制路径在读或者写时设置这个位，否则就清0。这个『未锁』标志存放在<em>lock</em>字段的第24位。</li>
</ol>

<p>如果自旋锁为空，那么<em>lock</em>字段的值位0x010000000，如果一个两个或者多个进程因为读获取了自旋锁，那么<em>lock</em>字段的值位0x00ffffff，0x00fffffe等。与<em>spinlock_t</em>结构一样，<em>rwlock_t</em>结构也包含<em>break_lock</em>字段。</p>

<p><em>rwlock_init</em>宏把读/写自旋锁的<em>lock</em>字段初始化位未锁的状态，把<em>break_lock</em>初始化为0。</p>

<h3 id="section">为读获取和释放一个锁</h3>

<p><em>read_lock</em>宏作用于读/写自旋锁的地址<em>rwlp</em>，与<em>spin_lock</em>宏非常相似，如果编译内核时选择了内核抢占选项，<em>read_lock</em>宏执行与<em>spin_lock()</em>非常相似的操作，只是有一点不同，该宏执行了<em>__raw_read_trylock()</em>函数获得读/写自旋锁。</p>

<h4 id="archx86includeasmspinlockh">&lt;arch/x86/include/asm/spinlock.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__raw_read_trylock</span><span class="p">(</span><span class="n">raw_rwlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">atomic_t</span> <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="p">)</span><span class="n">lock</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_return</span><span class="p">(</span><span class="n">count</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">atomic_inc</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>读/写锁计数器<em>lock</em>字段时通过原子操作来访问的，尽管如此，但整个函数对计数器的操作并不是原子性的。例如，在用<em>if</em>语句完成对计数器的值的测试之后并返回1之前，计数器的值可能发生变化。不过函数能够正常工作。</p>

<p>实际上，只有在递减之前计数器的值不为0或者负数的情况下，函数才返回1，因为计数器等于0x01000000表示没有任何进程占用锁，等于0x00ffffff表示有一个读者，而等于0x00000000表示有一个写者。</p>

<p><em>read_lock</em>宏原子地把自旋锁的值减去1，以此增加读者的个数，如果函数递减操作产生一个非复制，就获得自旋锁，否则就调用<em>__read_lock_failed()</em>函数，这个函数原子地增加<em>lock</em>字段以取消由<em>readl_lock</em>宏执行的递减操作，然后循环，直到<em>lock</em>字段变为正数。接下来，<em>__read_lock_failed()</em>又试图获得自旋锁。</p>

<p>解锁的过程相当简单，使用<em>read_unlock</em>宏只是简单的增加了<em>lock</em>字段的计数器以减少读者的计数，然后调用<em>preempt_enable()</em>重新启用内核抢占。</p>

<h3 id="section-1">为写获取和释放一个锁</h3>

<p><em>write_lock</em>宏的实现方式与<em>spin_lock()</em>和<em>read_lock()</em>相似，例如，如果支持内核抢占，则该函数禁用内核抢占并通过<em>__raw_write_trylock()</em>立即获得锁，如果该函数返回0，则说明锁已经被占用，然后该宏就重新启用内核抢占并开始等待循环。</p>

<h4 id="archx86includeasmspinlockh-1">&lt;arch/x86/include/asm/spinlock.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__raw_write_trylock</span><span class="p">(</span><span class="n">raw_rwlock_t</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">atomic_t</span> <span class="o">*</span><span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="n">atomic_t</span> <span class="o">*</span><span class="p">)</span><span class="n">lock</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">atomic_sub_and_test</span><span class="p">(</span><span class="n">RW_LOCK_BIAS</span><span class="p">,</span> <span class="n">count</span><span class="p">))</span>
        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">atomic_add</span><span class="p">(</span><span class="n">RW_LOCK_BIAS</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>函数<em>__raw_write_trylock()</em>从读/写自旋锁中减去0x01000000，从而清除未上锁标志，如果减操作产生0，说明没有读者，则获取锁并返回1，否则，函数原子地在自旋锁上加0x01000000以取消减操作。</p>

<p>释放锁同样就暗淡，使用<em>write_unlock</em>宏即可，将相应地位标记为未锁状态，然后再调用<em>preempt_enable()</em>重新启用内核抢占。</p>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#自旋锁">#自旋锁</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/irq-and-interrupt/" class="pre">&lt; IRQ和中断</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/alloc-page/" class="next">分配页 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 内核同步_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章读/写自旋锁写于2014年05月03日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
