<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>读-拷贝-更新|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 读-拷贝-更新 RCU..." name="description"/>
  <meta content="RCU,读-拷贝-更新," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/read-copy-update/" />
  <meta property="og:title" content="读-拷贝-更新" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 读-拷贝-更新 RCU..." />
</head>
<body>

<div class="banner">
<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/" class="glyphicon glyphicon-inbox"> Home</a></li>
  <li><a href="/archive" class="glyphicon glyphicon-floppy-disk"> Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/" class="glyphicon glyphicon-book"> Kernel</a></li>
  <li><a href="/about" class="glyphicon glyphicon-record"> About</a></li>
</ul>
</div>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">读-拷贝-更新</div>

  <div class="content 内核同步_content_css">
    <p>读-拷贝-更新（<em>RCU</em>）是为了保护在多数情况下被多个CPU读的数据结构而设计的一种同步技术，RCU允许多个读者和写者并发执行，相对于值允许一个写者执行的顺序锁，RCU有了本质上的改进。</p>

<p>简单的说RCU的逻辑是，当读者指向共享数据结构时，一旦有写者需要对共享数据结构进行写操作，那么写者就创建一个共享数据结构的副本，当完成写操作之后，将所有的读者指向新的数据结构，然后释放旧的数据结构即可。</p>

<p>RCU是不使用锁的，也就是说，它不使用被所用CPU共享的锁或计数器，在这一点上和读/写自旋锁和顺序锁相比，RCU具有更大的优势。RCU可以不使用共享数据机构而实现多个CPU同步，因为：</p>

<ol>
  <li>RCU只保护被动态分配并通过指针引用的数据结构。</li>
  <li>在被RCU保护的临界区中，任何内核控制路径都不能睡眠。</li>
</ol>

<p>当内核控制路径要读取被RCU保护的数据结构是，执行宏<em>rcu_read_lock()</em>，该宏等同于<em>preempt_disable()</em>函数。同样，也可以执行<em>rcu_read_unlock()</em>，这个宏等同于<em>preempt_enable()</em>，代码如下：</p>

<h4 id="includelinuxrcutreeh">&lt;include/linux/rcutree.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__rcu_read_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">preempt_disable</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__rcu_read_unlock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">preempt_enable</span><span class="p">();</span>
<span class="p">}</span></code></pre></div>

<p>接下来，读者间接引用该数据结构指针锁对应的内存单元并开始读这个数据结构，读者在完成对数据结构的读操作之前，是不能睡眠的，用<em>rec_read_unlock()</em>宏标记临界区的结束。</p>

<p>由于读者几乎不会做任何事情，所以也不会有任何竞争条件出现，所以写者不得不做得更多一些。实际上，当写者要更新数据结构的时候，它间接引用指针并生成整个数据结构的副本，然后，写者修改这个副本，一旦修改完毕，写者改变指向数据结构的指针，以便使它指向被修改后的副本。</p>

<p>由于修改指针值的操作是一个原子操作，所以旧副本和新副本对每个读者或写者都是可见的，在数据结构中并不会出现数据崩溃。尽管如此，还需要内存屏障来保证只有在数据结构被修改后，已更新的指针对其他CPU才是可见的，如果把自旋锁与RCU结合起来以禁止写者的并发执行，就隐含地引入了这样的内存屏障。</p>

<p>然而，使用RCU技术的真正困难在于，写者修改指针时不能立即释放数据结构的旧副本。实际上，写者开始修改时，正在访问数据结构的读者可能还在读旧副本，只有在CPU上的所有的读者都执行完<em>rcu_read_unlock()</em>之后，才可以释放旧的副本，内核要求每个潜在的读者在下面的操作之前执行<em>rcu_read_unlock()</em>宏。</p>

<ol>
  <li>CPU执行进程切换。</li>
  <li>CPU开始在用户态执行。</li>
  <li>CPU执行空循环。</li>
</ol>

<p>对于上述的每种情况，我们都说CPU已经经过了静止状态（<em>quiescent state</em>）。</p>

<p>写者调用函数<em>call_rcu()</em>来释放数据结构的旧副本，该函数定义如下。</p>

<h4 id="includelinuxrcupdateh">&lt;include/linux/rcupdate.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">extern</span> <span class="kt">void</span> <span class="n">call_rcu</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">));</span></code></pre></div>

<p>当所有的CPU都通过静止状态之后，<em>call_rcu()</em>接收<em>rcu_head</em>描述符<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>的地址和将要调用的回调函数的地址作为参数，一旦回调函数被执行，它同城释放数据结构的旧副本。</p>

<p>函数<em>call_rcu()</em>把回调函数和其他参数的地址存放在<em>rcu_head</em>描述符中，代码如下：</p>

<h4 id="includelinuxrcupdateh-1">&lt;include/linux/rcupdate.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">rcu_head</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">);</span>
<span class="p">};</span></code></pre></div>

<p>然后把描述符插入到回调函数的per-CPU链表中，内核每经过一个时钟抵达旧周期性地检查本地CPU是否经过了一个静止状态，如果所有的CPU都经过了静止状态，本地tasklet旧执行链表中的所有回调函数。</p>

<p>RCU最常用的场景是Linux中的网络层和虚拟文件系统。</p>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>这个描述符通常嵌在要被释放的数据结构中。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#RCU">#RCU</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#读-拷贝-更新">#读-拷贝-更新</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/mm-release/" class="pre">&lt; 释放页</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/working-on-exception/" class="next">异常处理 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 内核同步_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章读-拷贝-更新写于2014年05月05日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
