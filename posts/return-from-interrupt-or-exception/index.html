<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>从中断和异常返回|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 从中断和异常返回..." name="description"/>
  <meta content="中断,异常," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/return-from-interrupt-or-exception/" />
  <meta property="og:title" content="从中断和异常返回" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 从中断和异常返回..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">daf94cf87</a></li>
  <!--
  I love bettylwx
    -->
</ul>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">从中断和异常返回</div>

  <div class="content 中断和异常_content_css">
    <p>在恢复中断和异常之后，通常直接恢复某个程序的执行即可，但是在这样做之前，还必须要考虑几个问题：</p>

<ol>
  <li>内核控制路径并发的执行数量，如果仅仅只有一个，那么CPU必须切换到用户态。</li>
  <li>挂起进程的切换请求，如果有任何请求，内核就必须执行进程调度，否则，把控制权还给当前进程。</li>
  <li>挂起的信号，如果一个信号发送到当前进程，就必须处理它。</li>
  <li>单步执行模式，如果调试程序正在跟着当前的进程的执行，就必须在进程切换回到用户态之前恢复单步执行。</li>
  <li>Virtual-8086模式，如果CPU处以该模式，则当前进程正在执行原来实模式程序，因而必须以特殊的方式处理这种情况。</li>
</ol>

<p>需要使用一些标志来记录挂起进程切换的请求、挂起信号和单步执行，这些标志被存放在<em>thread_info</em>描述符的<em>flags</em>字段中，这个字段也存放其他与中断和异常返回无关的标志，这些标志包含：</p>

<table class="table_center">
  <thead>
    <tr>
      <th>标志</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>TIF_SYSCALL_TRACE</td>
      <td>正在跟踪系统调用</td>
    </tr>
    <tr>
      <td>TIF_NOTIFY_RESUME</td>
      <td>在80x86平台上不使用</td>
    </tr>
    <tr>
      <td>TIF_SIGPENDING</td>
      <td>进程有挂起信号</td>
    </tr>
    <tr>
      <td>TIF_NEED_RESCHED</td>
      <td>必须执行调度程序</td>
    </tr>
    <tr>
      <td>TIF_SINGLESTEP</td>
      <td>临返回用户态前恢复单步执行</td>
    </tr>
    <tr>
      <td>TIF_IRET</td>
      <td>通过iret而不是sysexit从系统调用强行返回</td>
    </tr>
    <tr>
      <td>TIF_SYSCALL_AUDIT</td>
      <td>系统调用正在被审计</td>
    </tr>
    <tr>
      <td>TIF_POLLING_NRFLAG</td>
      <td>空闲进程正在轮询TIF_NEED_RESCHED标志</td>
    </tr>
    <tr>
      <td>TIF_MEMDIE</td>
      <td>正在撤销进程以回收内容</td>
    </tr>
  </tbody>
</table>

<p>从技术上来说，完成所有这些事情的内核汇编语言代码并不是一个函数，因为控制权从不返回到调用它的函数，它只是一个代码片段，有两个不同的入口点，分别叫做<em>ret_from_intr()</em>和<em>ret_from_exception()</em>。</p>

<p>中断处理程序结束时，内核进入<em>ret_from_intr()</em>，而当异常处理程序结束时，它进入<em>ret_from_exception</em>。这两个入口点并不是两个函数，只是因为方便而如此使用。具体的实现是晦涩的汇编语言，也许在今后的笔记中会更详细的记录。</p>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#中断">#中断</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#异常">#异常</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/work-queue/" class="pre">&lt; 工作队列</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/slab-alloc/" class="next">slab分配 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 中断和异常_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章从中断和异常返回写于2014年05月13日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
