<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>Linux中的分段|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 Linux中的分段..." name="description"/>
  <meta content="分段,GDT,全局描述符表,RPL,TLS," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/segment-in-linux/" />
  <meta property="og:title" content="Linux中的分段" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 Linux中的分段..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">daf94cf87</a></li>
  <!--
  I love bettylwx
    -->
</ul>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">Linux中的分段</div>

  <div class="content 内存寻址_content_css">
    <p>80x86处理器中的分段鼓励程序员把程序分成逻辑上相关的实体，比如子程序或者全局与局部的数据区。然而，Linux以非常有限的方式使用分段，实际上分段和分页某种程度上有点多余，因为它们都可以划分进程的物理地址空间。分段可以给每一个进程分配不同的线性地址空间，而分页可以把同一线性地址空间映射到不同的物理空间。与分段相比，Linux更喜欢分页的方式：</p>

<ul>
  <li>当所有进程使用相同的段寄存器时，内存管理变得简单，它们可以共享同一组线性定制。</li>
  <li>Linux设计目标之一时可以把它移植到绝大多数留下的处理器平台上，然而RISC<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>体系结构对分段的支持有限。</li>
</ul>

<p>2.6版本的Linux只有在80x86结构下才需要使用分段。</p>

<p>运行在用户态的所有Linux进程都使用一对相对的段来对指令和数据寻址。这两个段就是所谓的用户代码段和用户数据段，类似地，运行在内核态的所有Linux进程都使用一对相同的段对指令和数据寻址：它们分别叫做内核代码段和内核数据段。</p>

<p>相应的段选择符由宏__USER_CS，__USER_DS，__KERNEL_CS和__KERNEL_DS分别定义。如果为了对内核代码段寻址，内核只需要把__KERNEL_CS装进cs段寄存器就好。而对内核数据段寻址，则将__KERNEL_DS装进ds段寄存器。</p>

<p>所有与段相关的线性地址从0开始，到达2^32-1的寻址限长。所以用户态或内核态下的所有进程可以使用相同的逻辑地址。而所有段从0开始，可以得出，在Linux下逻辑地址与线性地址是一致的，即<strong>逻辑地址的偏移量字段的值与相应的线性地址的值总是一致的</strong>。</p>

<p>CPU当前的特权级（<em>CPL</em>）反映了进程是在用户态还是内核态，并由存放在<em>cs</em>寄存器中的段选择符的<em>RPL</em>字段指定。只要当前特权级被改变，一些段寄存器必须相应地更新。例如CPL=3时，说明在用户态，<em>ds</em>寄存器必须含有用户端的段选择符，如果进入内核态，则CPL=0，<em>ds</em>寄存器则必须含有内核数据段的段选择符。</p>

<p>这种情况也出现在<em>ss</em>寄存器中，当CPL为3时，它必须指向一个用户数据段中的用户栈。当CPL=0时，它必须指向内核数据段中的一个内核栈。当状态转换时，Linux总是确保<em>ss</em>寄存器中装有相应权限的数据段的段选择符。</p>

<p>当对指向指令或者数据结构指针进行保存时，内核根本不需要为其设置逻辑地址的段选择符。因为<em>cs</em>寄存器就含有当前的段选择符。例如，当内核调用一个函数时，它执行一条<em>call</em>汇编语言指令，该指令仅仅指定其逻辑地址的偏移量部分。而段选择符不用设置，它已经隐含在<em>cs</em>寄存器中了。因为在内核态执行的段只有一种，叫做代码段，由宏__KERNEL_CS定义。</p>

<p>所以只要当CPU切换到内核态时将__KERNEL_CS装载到<em>cs</em>就足够了。同样的道理也适用于指向内核数据结构的指针以及指向用户结构的指针。实际上这里只需要了解，每当CPU特权级更新，内核就应该保证相应的寄存器存放相应的段选择符。</p>

<h3 id="linux-gdt">Linux GDT</h3>

<p>在单处理器系统只有一个全局描述符表（<em>GDT</em>），在多处理器中每个CPU对应一个GDT。所有GDT都存放在<em>cpu_gdt_table</em>数组中，而所有GDT的地址和它们的大小被存放在<em>cpu_gdt_descr</em>数组中。在新的内核中更建议使用<em>get_cpu_gdt_table</em>函数，其参数为<em>cpu</em>的实例。</p>

<p>GDT的布局如下，每个GDT包含18个段描述符和14个空的未使用的保留项。插入未使用的项时为了使经常一起访问的描述符能够处于同一32字节的硬件高速缓存中。</p>

<p class="center"><img src="/linux-kernel-architecture/images/gdt.png" alt="system" /></p>

<p class="center">GDT结构表</p>

<p>每一个GDT中包含的18个段描述符指向下列的段：</p>

<p>用户态和内核态下的代码段和数据段，如__USER_CS，__USER_DS，__KERNEL_CS和__KERNEL_DS。</p>

<p>任务状态段（<em>TSS</em>），每个处理器有1个，每个TSS相应的线性地址空间都是内核数据段相应线性地址空间的一个小子集。所有的任务状态段都是顺序地存放在<em>init_tss</em>数组中。</p>

<p>1个包括缺省局部描述符表的段，这个段通常是被所有进程共享的段。</p>

<p>3个局部线程存储（<em>Thread-Local Storage，TLS</em>）段：这种机制允许多线程应用程序使用最多3个局部线程的数据段。系统调用<em>set_thread_area</em>和<em>get_thread_area</em>分别为正在执行的进程创建和撤销一个TLS段</p>

<p>与高级电源管理（<em>AMP</em>）相关的3个段，由BIOS代码使用。</p>

<p>与支持即插即用（<em>PnP</em>）功能的BIOS服务程序相关的5个段，由BIOS代码使用。</p>

<p>被内核用来处理双重错误<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>异常的特殊TSS段。</p>

<p>其实看图就已经非常好理解了。</p>

<h3 id="linux-ldt">Linux LDT</h3>

<p>大多数用户态下的Linux程序不使用局部描述符表，这样内核就定义了一个缺省的LDT供大多数进程共享。缺省的局部描述附表放在<em>default_ldt</em>数组中。它包含5个项，但内核仅仅有效地使用了其中的两个项：用于iBCS执行文件的调用门和Solaris/x86可执行文件的调用门<sup id="fnref:3"><a href="#fn:3" class="footnote">3</a></sup>。</p>

<p>在某些情况下，进程仍需要创建自己的局部描述符表，这对有些应用程序很有用，比如Wine，它们执行面向段的微软Windows应用程序。<em>modify_ldt()</em>系统调用允许进程创建自己的局部描述符表。</p>

<p>任何被<em>modify_ldt()</em>创建的自定义局部描述符表仍然需要它自己的段。当处理器开始执行拥有自定义局部描述符表的进程时，该CPU的GDT副本中的LDT表项相应地就被修改了。</p>

<p>用户态下地程序同样也利用<em>modify_ldt()</em>来分配新地段，但内核从不使用这些段，它也不需要了解相应地段描述符，因为这些段描述符被包含在进程自定义的局部描述符表中了。</p>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>精简指令集系统，大多数系统还属于CISC（<em>complex instruction set computer</em>，复杂指令集）系统。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>处理一个异常时可能引发另一个异常，这种情况下产生双重异常。 <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:3">
      <p>调用门是80x86微处理器提供的一种机制，用于在调用预定义函数时改变CPU的特权级。 <a href="#fnref:3" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <hr>
  <div class="eof">EOF</div>
  <hr>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#分段">#分段</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#GDT">#GDT</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#全局描述符表">#全局描述符表</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#RPL">#RPL</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#TLS">#TLS</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/visit-segment-descriptor/" class="pre">&lt; 访问段描述符及分段单元</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/system-paging-unit/" class="next">硬件中的分页 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 内存寻址_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章Linux中的分段写于2014年04月15日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
