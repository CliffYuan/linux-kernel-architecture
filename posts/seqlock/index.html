<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>顺序锁|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 顺序锁..." name="description"/>
  <meta content="顺序锁," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/seqlock/" />
  <meta property="og:title" content="顺序锁" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 顺序锁..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">Home</a></li>
  <li><a href="/archive/">Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/">Kernel</a></li>
</ul>

</div>

<div class="container">

<div class="main clearfix">
  <div class="title">顺序锁</div>

  <div class="content kernel_preemption内核同步_content_css">
    <p>当使用读/写自旋锁时，内核控制路径发出的执行<em>read_lock</em>或<em>write_lock</em>操作的请求具有相同的优先级，读者必须等待，直到写操作完成，同样，写者也必须等待，直到读操作的完成。</p>

<p>Linux2.6中引入了顺序锁（<em>seqlock</em>），它与读/写自旋锁非常相似，只是它为写者赋予了较高的优先级，事实上，即使在读者正在读的时候也可以允许写者继续运行。这种策略的好处时写者永远不会等待，除非另一个写者也尝试写入同样的一个数据结构。但同样有缺点，缺点时有些时候读者不得不反复多次读取相同的数据结构直到获得它有效的副本。</p>

<p>每个顺序所都是包括两个字段的<em>seqlock_t</em>结构，代码如下：</p>

<h4 id="includelinuxseqlockh">&lt;include/linux/seqlock.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">sequence</span><span class="p">;</span>
    <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">}</span> <span class="n">seqlock_t</span><span class="p">;</span></code></pre></div>

<p><em>seqlock_t</em>是一个包含两个字段的结构，其中一个类型为<em>spinlock_t</em>的<em>lock</em>锁字段，用于实现锁，而<em>sequence</em>是一个顺序计数器。每个读者都必须在读取数据前后两次读顺序计数器，并检查两次读到的值是否相同，如果不相同，说明新的写者已经开始写并增加了顺序计数器，所以刚才读到的数据结构是无效的。</p>

<p>初始化一个顺序锁的代码如下：</p>

<h4 id="includelinuxseqlockh-1">&lt;include/linux/seqlock.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define seqlock_init(x)
</span>    <span class="k">do</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sequence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="mi">0</span><span class="p">)</span></code></pre></div>

<p>通过把<em>SEQLOCK_UNLOCKED</em>赋值给变量<em>seqlock_t</em>或执行<em>seqlock_init</em>宏可以将锁初始化为未锁的状态。从上面的代码可以看出，除了初始化锁，也将读取顺序计数器初始化为0。</p>

<p>写者通过调用<em>write_seqlock()</em>和<em>write_sequnlock()</em>获取和释放顺序锁，第一个函数获取<em>seqlock_t</em>数据结构中的自旋锁，然后使顺序计数器加1，第二个函数再次增加顺序计数器，然后释放自旋锁，这样可以保证写者在写的过程中，计数器会是技术，并且当没有写者改变数据的时候，计数器的值是偶数。</p>

<h4 id="includelinuxseqlockh-2">&lt;include/linux/seqlock.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_seqlock</span><span class="p">(</span><span class="n">seqlock_t</span> <span class="o">*</span><span class="n">sl</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
    <span class="o">++</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">;</span>
    <span class="n">smp_wmb</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">write_sequnlock</span><span class="p">(</span><span class="n">seqlock_t</span> <span class="o">*</span><span class="n">sl</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">smp_wmb</span><span class="p">();</span>
    <span class="n">sl</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="o">++</span><span class="p">;</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sl</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p><em>read_seqbegin()</em>返回顺序锁当前的顺序号，如果局部变量<em>seq</em>的值是负数，或者<em>seq</em>的值与顺序所的顺序计数器的当前值不匹配，那么该函数就返回1。</p>

<h4 id="includelinuxseqlockh-3">&lt;include/linux/seqlock.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="nf">read_seqcount_begin</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">seqcount_t</span> <span class="o">*</span><span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">repeat:</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">sequence</span><span class="p">;</span>
    <span class="n">smp_rmb</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">cpu_relax</span><span class="p">();</span>
        <span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>当读者进入临界区时，无需禁用内核抢占，另一方面，由于写者获取自旋锁，所以它进入临界区时自动禁用内核抢占。当然，并不是每一种锁都可以使用顺序锁来保护，如果要使用顺序锁，则必须满足以下条件：</p>

<ol>
  <li>被保护的数据结构不包括被写者和被读者间接引用的指针。</li>
  <li>读者的临界区代码没有副作用<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。</li>
</ol>

<p>此外，读者临界区代码应该简短，而且写者应该不常获取顺序所，否则，反复的读访问会引起严重的开销，在Linux中，使用顺序锁的典型例子包括保护一些与系统时间处理相关的数据结构。</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>否则多个读者的操作会与单独的读操作有不同的结果。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#顺序锁">#顺序锁</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/interrupt-descriptor-table/" class="pre">&lt; 中断描述符表</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/loop-interrupt/" class="next">处理程序的嵌套执行 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments kernel_preemption内核同步_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章顺序锁写于2014年05月04日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
