<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>slab分配|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 slab分配..." name="description"/>
  <meta content="slab," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/slab-alloc/" />
  <meta property="og:title" content="slab分配" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 slab分配..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">daf94cf87</a></li>
  <!--
  I love bettylwx
    -->
</ul>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">slab分配</div>

  <div class="content 内存管理_content_css">
    <p>slab的分配使用<em>kmem_cache_alloc</em>函数，这个函数的流程图如下：</p>

<p class="center"><img src="/linux-kernel-architecture/images/slab_alloc.png" alt="slab" style="max-width:600px" /></p>

<h4 id="mmslabc">&lt;mm/slab.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="o">*</span><span class="nf">kmem_cache_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">__cache_alloc</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

    <span class="n">trace_kmem_cache_alloc</span><span class="p">(</span><span class="n">_RET_IP_</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
                   <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">),</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">buffer_size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">kmem_cache_alloc</span><span class="p">);</span></code></pre></div>

<p>可以看到无论是<em>kmalloc</em>或者<em>kmem_cache_alloc</em>最后都会调用到<em>__cache_alloc</em>函数，而<em>__cache_alloc</em>最后都会调用到<em>____cache_alloc</em>函数<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。</p>

<h4 id="mmslabc-1">&lt;mm/slab.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">____cache_alloc</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span><span class="p">;</span>

    <span class="n">check_irq_off</span><span class="p">();</span>

    <span class="n">ac</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">STATS_INC_ALLOCHIT</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
        <span class="n">ac</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">objp</span> <span class="o">=</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="o">--</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">];</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">STATS_INC_ALLOCMISS</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
        <span class="n">objp</span> <span class="o">=</span> <span class="n">cache_alloc_refill</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">kmemleak_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">]);</span>
    <span class="k">return</span> <span class="n">objp</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>从上面的代码来看，<em>cachep</em>是一个指针，指向缓存使用的<em>kmem_cache_t</em>实例，<em>ac_data</em>宏通过返回<em>cachep-&gt;array[smp_processor_id()]</em>，从而获得当前活动CPU相关的<em>array_cache</em>实例。</p>

<p>因为内存中的对象紧跟<em>array_cache</em>实例之后，内核可以借助该结构末尾的伪数组访问对象而不需要使用指针，通过将<em>ac-&gt;avail</em>减去1，就可以将对象从缓存中移除。</p>

<p>如果在per-CPU中没有对象的话，就需要调用<em>cache_alloc_refill</em>方法来重新填充。</p>

<h4 id="mmslabc-2">&lt;mm/slab.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">cache_alloc_refill</span><span class="p">(</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">batchcount</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">node</span><span class="p">;</span>

<span class="nl">retry:</span>
    <span class="n">check_irq_off</span><span class="p">();</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">numa_node_id</span><span class="p">();</span>
    <span class="n">ac</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
    <span class="n">batchcount</span> <span class="o">=</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">batchcount</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">&amp;&amp;</span> <span class="n">batchcount</span> <span class="o">&gt;</span> <span class="n">BATCHREFILL_LIMIT</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* 检查batchcount的值 */</span>
        <span class="n">batchcount</span> <span class="o">=</span> <span class="n">BATCHREFILL_LIMIT</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>

    <span class="n">BUG_ON</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">!</span><span class="n">l3</span><span class="p">);</span>
    <span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

    <span class="cm">/* 检查是否可以从共享数组中重新填充 */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span> <span class="o">&amp;&amp;</span> <span class="n">transfer_objects</span><span class="p">(</span>
        <span class="n">ac</span><span class="p">,</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">shared</span><span class="p">,</span> <span class="n">batchcount</span><span class="p">))</span>
        <span class="k">goto</span> <span class="n">alloc_done</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">batchcount</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>
        <span class="cm">/* 获取对象的slab链表 */</span>
        <span class="n">entry</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
        <span class="cm">/* 首先是slabs_partial，然后是slabs_free */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_touched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">)</span>
                <span class="k">goto</span> <span class="n">must_grow</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">slabp</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">slab</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
        <span class="n">check_slabp</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>
        <span class="n">check_spinlock_acquired</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>

        <span class="cm">/*
         * 如果slab不在partial或者free连表中
         * 那么至少有一个对象可以被分配
         */</span>
        <span class="n">BUG_ON</span><span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">&gt;=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">&lt;</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span> <span class="o">&amp;&amp;</span> <span class="n">batchcount</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">STATS_INC_ALLOCED</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
            <span class="n">STATS_INC_ACTIVE</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
            <span class="n">STATS_SET_HIGH</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>

            <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">slab_get_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span>
                                <span class="n">node</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">check_slabp</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>

        <span class="cm">/* 将slab移动到正确的slab连表中 */</span>
        <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">free</span> <span class="o">==</span> <span class="n">BUFCTL_END</span><span class="p">)</span>
            <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_full</span><span class="p">);</span>
        <span class="k">else</span>
            <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">must_grow:</span>
    <span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span> <span class="o">-=</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">;</span>
<span class="nl">alloc_done:</span>
    <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">cache_grow</span><span class="p">(</span>
            <span class="n">cachep</span><span class="p">,</span> <span class="n">flags</span> <span class="o">|</span> <span class="n">GFP_THISNODE</span><span class="p">,</span>
            <span class="n">node</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

        <span class="n">ac</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">)</span>
            <span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">ac</span><span class="o">-&gt;</span><span class="n">touched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="o">--</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="p">];</span>
<span class="p">}</span></code></pre></div>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>四个下划线。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#slab">#slab</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/return-from-interrupt-or-exception/" class="pre">&lt; 从中断和异常返回</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/super-block-object/" class="next">超级块对象 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 内存管理_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章slab分配写于2014年05月13日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
