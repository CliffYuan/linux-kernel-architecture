<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>slab释放|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 slab释放..." name="description"/>
  <meta content="slab,释放," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/slab-free/" />
  <meta property="og:title" content="slab释放" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 slab释放..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">daf94cf87</a></li>
  <!--
  I love bettylwx
    -->
</ul>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">slab释放</div>

  <div class="content 内存管理_content_css">
    <p>如果一个已经分配的对象已经不再需要，那么必须使用<em>kmem_cache_free</em>函数将已经分配的slab返回给slab分配器。</p>

<p class="center"><img src="/linux-kernel-architecture/images/slab6.png" alt="slab" style="max-width:400px" /></p>

<p class="center">slab释放的流程图</p>

<p><em>kmem_cache_free</em>实际上是一个<em>__cache_free</em>的接口，直接调用了该函数，参数直接传递过去，其原因也是防止<em>kfree</em>实现中的代码复制。</p>

<p>类似于分配，根据per-CPU缓存状态的不同，可以有两种操作流程，如果per-CPU缓存中的对象数目低于允许的限制，则在其中存储一个指向缓存中对象的指针。</p>

<h4 id="mmslabc">&lt;mm/slab.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__cache_free</span><span class="p">(</span>
    <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">ac</span> <span class="o">=</span> <span class="n">cpu_cache_get</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>

    <span class="n">check_irq_off</span><span class="p">();</span>
    <span class="n">kmemleak_free_recursive</span><span class="p">(</span><span class="n">objp</span><span class="p">,</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
    <span class="n">objp</span> <span class="o">=</span> <span class="n">cache_free_debugcheck</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">__builtin_return_address</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>

    <span class="n">kmemcheck_slab_free</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">obj_size</span><span class="p">(</span><span class="n">cachep</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">nr_online_nodes</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">cache_free_alien</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">objp</span><span class="p">))</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span> <span class="o">&lt;</span> <span class="n">ac</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">STATS_INC_FREEHIT</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
        <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">objp</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">STATS_INC_FREEMISS</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
        <span class="n">cache_flusharray</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">ac</span><span class="p">);</span>
        <span class="n">ac</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">[</span><span class="n">ac</span><span class="o">-&gt;</span><span class="n">avail</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">objp</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>从上面的代码可以看出，这样的操作是很必要的，否则，必须将一些对象从缓存移回slab，从编号最低的数组元素开始：缓存的实现一句先进先处的原理，这些对象在数组中已经很长时间，因此不太可能依然驻留在CPU高速缓存中。</p>

<p>具体的实现交给函数<em>cache_flusharray</em>，这个函数又调用了<em>free_block</em>，将对象从缓存移动到原来的slab，并将剩余的对象向数组起始处移动。例如，如果缓存中有30个对象的空间，而<em>batchcoucnt</em>为15，则位置0到14的对象将会移回slab，剩余编号15～29的对象则在缓存中向上移动，现在占据位置0～14.</p>

<p>将对象从缓存移回到slab是非常有用的，我们看<em>free_block</em>代码如下：</p>

<h4 id="mmslabc-1">&lt;mm/slab.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kt">void</span> <span class="nf">free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cachep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">objpp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_objects</span><span class="p">,</span>
               <span class="kt">int</span> <span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">kmem_list3</span> <span class="o">*</span><span class="n">l3</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_objects</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">objp</span> <span class="o">=</span> <span class="n">objpp</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">struct</span> <span class="n">slab</span> <span class="o">*</span><span class="n">slabp</span><span class="p">;</span>

        <span class="n">slabp</span> <span class="o">=</span> <span class="n">virt_to_slab</span><span class="p">(</span><span class="n">objp</span><span class="p">);</span>
        <span class="n">l3</span> <span class="o">=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">nodelists</span><span class="p">[</span><span class="n">node</span><span class="p">];</span>
        <span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
        <span class="n">check_spinlock_acquired_node</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="n">check_slabp</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>
        <span class="n">slab_put_obj</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">,</span> <span class="n">objp</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="n">STATS_DEC_ACTIVE</span><span class="p">(</span><span class="n">cachep</span><span class="p">);</span>
        <span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span><span class="o">++</span><span class="p">;</span>
        <span class="n">check_slabp</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>

        <span class="cm">/* 临时的slab重新插入缓存链表 */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">inuse</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span> <span class="o">&gt;</span> <span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_limit</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">l3</span><span class="o">-&gt;</span><span class="n">free_objects</span> <span class="o">-=</span> <span class="n">cachep</span><span class="o">-&gt;</span><span class="n">num</span><span class="p">;</span>
                <span class="n">slab_destroy</span><span class="p">(</span><span class="n">cachep</span><span class="p">,</span> <span class="n">slabp</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_free</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">slabp</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">l3</span><span class="o">-&gt;</span><span class="n">slabs_partial</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>这个函数在更新缓存数据结构中没有使用对象的数目之后，遍历<em>objpp</em>中的所有对象。并对每个对象执行<em>virt_to_slab</em>函数。</p>

<p>在确定对象所属的slab之前，首先必须调用<em>virt_to_slab</em>函数找到对象所在的页，与slab之间的关联使用<em>page_get_slab</em>来确定。</p>

<p>临时的slab从缓存的链表中移除，<em>slab_put_obj</em>反应了在空闲链表中的这种操作，用于分配的第一个对象是刚刚删除的，而列表中的下一个对象则是此前的第一个对象，此后，该slab重新插入到缓存的链表中。</p>

<p>释放缓存和销毁缓存还有所不同，销毁缓存使用<em>kmem_cache_destory</em>函数，这个函数主要在删除模块的时候调用，这个时候需要将分配的内存全部释放。该函数进行一下三步来释放一个模块内的所有内存：</p>

<ol>
  <li>依次扫描slabs_free链表上的slab，将slab返回给伙伴系统。</li>
  <li>释放用于pre-CPU缓存的内存空间。</li>
  <li>从cache_cache链表移除相关数据。</li>
</ol>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#slab">#slab</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#释放">#释放</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/inode-object/" class="pre">&lt; 索引节点对象</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/file-object/" class="next">文件对象 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 内存管理_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章slab释放写于2014年05月14日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
