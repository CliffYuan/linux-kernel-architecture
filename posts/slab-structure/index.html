<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>slab数据结构|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 slab数据结构..." name="description"/>
  <meta content="slab," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/slab-structure/" />
  <meta property="og:title" content="slab数据结构" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 slab数据结构..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">daf94cf87</a></li>
  <!--
  I love bettylwx
    -->
</ul>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">slab数据结构</div>

  <div class="content 内存管理_content_css">
    <p>为了实现slab分配器，需要各种数据结构，尽管看上去呢并不困难，相关的代码并不总是容易阅读或理解的，这是因为学多内存区需要使用指针运算和类型转换进行操作，这些可不是C语言中以清晰简明著称的领域。由于slab系统带有大量的调试选项，所以代码中遍布着预处理器语句，其中一些如下列出：</p>

<p>危险区（<em>Red Zoning</em>）</p>

<p>在每个对象的开始和结束处增加一个额外的内存区，其中填充已知的字节模式，如果模式被修改，程序员在分析内核内存时注意到，可能某些代码访问了不属于它们的内存区。</p>

<p>对象毒化（<em>Object Poisoning</em>）</p>

<p>在建立和释放slab时，将对象用预定义的模式填充，如果在对象分配时注意到该模式已经改变，程序员就知道已经发生了未授权的访问。</p>

<p>为了简明，我们可以关注整体而不是细节，所以我们只关注一个纯粹的slab分配器。</p>

<h3 id="section">数据结构</h3>

<p>每个缓存由<em>kmem_cache</em>结构的一个实例表示，代码如下：</p>

<h4 id="includelinuxslabdefh">&lt;include/linux/slab_def.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">kmem_cache</span> <span class="p">{</span>
<span class="cm">/* 1) per-CPU数据，在每次分配和释放的时候都会访问 */</span>
    <span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">array</span><span class="p">[</span><span class="n">NR_CPUS</span><span class="p">];</span>
<span class="cm">/* 2) 可调整的缓存的参数，由cache_chain_mutex保护 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">batchcount</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">shared</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">buffer_size</span><span class="p">;</span>
    <span class="n">u32</span> <span class="n">reciprocal_buffer_size</span><span class="p">;</span>
<span class="cm">/* 3) 在后端每次分配和释放内存时访问 */</span>

    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>     <span class="cm">/* 常数标志 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>       <span class="cm">/* 每个slab中对象的数量 */</span>

<span class="cm">/* 4) 缓存的增长和缩减 */</span>
    <span class="cm">/* 每个slab中的页数，取以2为底数的对数 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">gfporder</span><span class="p">;</span>

    <span class="cm">/* 强制内存区域的GFP标志, 比如GFP_DMA */</span>
    <span class="n">gfp_t</span> <span class="n">gfpflags</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">colour</span><span class="p">;</span>          <span class="cm">/* 缓存着色范围 */</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">colour_off</span><span class="p">;</span>    <span class="cm">/* 着色的偏移量 */</span>
    <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">slabp_cache</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slab_size</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">dflags</span><span class="p">;</span>        <span class="cm">/* 动态标志 */</span>

    <span class="cm">/* 构造函数 */</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">ctor</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">);</span>

<span class="cm">/* 5) 创建和移除缓存 */</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">next</span><span class="p">;</span>

<span class="cm">/* 6) 统计 */</span>
<span class="cp">#ifdef CONFIG_DEBUG_SLAB
</span>    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_active</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_allocations</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">high_mark</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">grown</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reaped</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">errors</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_freeable</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_allocs</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_frees</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">node_overflow</span><span class="p">;</span>
    <span class="n">atomic_t</span> <span class="n">allochit</span><span class="p">;</span>
    <span class="n">atomic_t</span> <span class="n">allocmiss</span><span class="p">;</span>
    <span class="n">atomic_t</span> <span class="n">freehit</span><span class="p">;</span>
    <span class="n">atomic_t</span> <span class="n">freemiss</span><span class="p">;</span>

    <span class="cm">/*
     * DEBUG
     */</span>
    <span class="kt">int</span> <span class="n">obj_offset</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">obj_size</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_DEBUG_SLAB */</span><span class="cp">
</span>
    <span class="cm">/*
     * 静态定义的一些变量
     * /
    struct kmem_list3 *nodelists[MAX_NUMNODES];
    /*
     * 不要在nodelists后面写变量
     * 因为我们需要定义这个数组的长度到
     * nr_node_ids，而不是使用MAX_NUMNODES
     * 看 kmem_cache_init() 函数
     */</span>
<span class="p">};</span></code></pre></div>

<p>在开始的几个成员涉及每次分配期间内核对特定于CPU数据的访问，除此之外还有几个重要的变量需要关注：</p>

<table>
  <thead>
    <tr>
      <th>字段</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>array</td>
      <td>是一个指向数组的指针，每个数组项都对应于系统中的一个CPU，每个数组项都包含了另一个指针，指向下文讨论的<em>array_cache</em>结构的实例</td>
    </tr>
    <tr>
      <td>batchcount</td>
      <td>指定了在per-CPU列表为空的情况下，从缓存的slab中获取对象的数目，它还表示在缓存增长时分配的对象数目</td>
    </tr>
    <tr>
      <td>limit</td>
      <td>指定了per-CPU列表中保存的对象的最大数目。如果超出了这个值，内核会将<em>batchcount</em>个对象返回到slab</td>
    </tr>
    <tr>
      <td>buffer_size</td>
      <td>指定了缓存中管理的对象的长度<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></td>
    </tr>
    <tr>
      <td>gfporder</td>
      <td>指定了slab包含的页数目以2为底的对数，简而言之，slab包含2^gfporder页</td>
    </tr>
    <tr>
      <td>colorur</td>
      <td>指定了颜色的最大数目</td>
    </tr>
    <tr>
      <td>colorur_next</td>
      <td>则时内核建立的下一个slab的颜色</td>
    </tr>
    <tr>
      <td>colour_off</td>
      <td>基本偏移量乘以颜色值获得的绝对偏移量</td>
    </tr>
    <tr>
      <td>dflags</td>
      <td>另一标志集合，描述slab的动态性质。</td>
    </tr>
    <tr>
      <td>ctor</td>
      <td>一个指针，指向在对象创建时调用的构造函数。</td>
    </tr>
    <tr>
      <td>name</td>
      <td>一个字符串，表示缓存的名称</td>
    </tr>
    <tr>
      <td>next</td>
      <td>是一个标准链表元素</td>
    </tr>
  </tbody>
</table>

<p>假定内核有一个指针指向slab中的一个元素，而需要确定对应的对象索引，最容易的方法是将指针指向对象地址，减去slab内存区的起始地址，然后将获得的对象偏移量，除以对象的长度。</p>

<p>考虑一个例子，一个slab内存区起始于内存位置100，每个对象需要5个字节，则，上文所述的对象位于内存位置115。对象和slab的起始处之间的偏移量为115-100=15，因此对象索引时15/5=3。</p>

<p>由于乘法在计算机上快得多，所以内核使用所谓的<a href="http://en.wikipedia.org/wiki/Newton's_method">Newton-Raphson</a>方法，这只需要乘法和位移，虽然我们对数学细节并不关系，但我们需要知道，内核可以不计算C=A/B，而是使用<em>C=reciprocal_divide(A, reciprocal_value(B))</em>的方式，后者涉及的两个函数都是库程序，由于特定slab中的对象长度时恒定的，内核可以将<em>buffer_size</em>的<em>recpirocal</em>值存储在<em>recpirocal_buffer_size</em>中，该值可以在后续的除法算法中使用。</p>

<p>如果slab头部的管理数据存储在slab外部，则<em>slabp_cache</em>指向反派所需内存的一般性缓存。如果slab头部在slab上，则<em>slabp_cache</em>为NULL指针。</p>

<hr />

<p>内核对每个系统处理器都提供了一个<em>array_cache</em>，代码如下：</p>

<h4 id="mmslabc">&lt;mm/slab.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">array_cache</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">avail</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">limit</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">batchcount</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">touched</span><span class="p">;</span>
    <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">entry</span><span class="p">[];</span>  <span class="cm">/*
             * 为了对齐array_cache，必须定义在这里
             */</span>
<span class="p">};</span></code></pre></div>

<p>我们已经知道了<em>batchcount</em>和<em>limit</em>的语义，<em>kmem_cache_s</em>的值用作per-CPU值的默认值，用于缓存和重新填充或清空。</p>

<table>
  <thead>
    <tr>
      <th>字段</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>avail</td>
      <td>保存了当前可用对象的数目，在从缓存移除一个对象时，将<em>touched</em>设置为1，而缓存收缩的时候，将<em>touched</em>设置为0。这使得内核能够确认在缓存上一次收缩之后是否被访问过，也是缓存重要性的一个标志</td>
    </tr>
    <tr>
      <td>entry</td>
      <td>是一个伪数组，从注释中我们可以看到，其中并没有数组项，只是为了便于访问内存中<em>array_cache</em>实例之后缓存中的各个对象而已</td>
    </tr>
  </tbody>
</table>

<p>再回头看<em>kmem_cache</em>后续的代码，其中<em>falgs</em>时一个标志寄存器，定义缓存的全局性质，当前只有一个标志位，如果管理结构存储在slab外部，则置<em>CFLAGS_OFF_SLAB</em>。</p>

<p><em>objectsize</em>是缓存中对象的长度，包括用于对齐目的的所有填充字节。<em>num</em>保存了可以放入slab的对象的最大数目。<em>free_limit</em>指定了缓存在收缩之后空闲对象的上限。</p>

<p>除了以上这些变量，还有一个必须说明，就是<em>nodelists</em>。<em>nodelists</em>是一个数组，每个数组项对应于系统中一个可能的内存节点，每个数组项都包含<em>kmem_list3</em>的一个实例，该结构中有三个slab列表，正如我们之前笔记所说的，包含完全用尽、空闲和部分空闲的三个slab列表。</p>

<p>这个成员必须置于结构的末尾，尽管数组形式化总是有<em>MAX_NUMNODES</em>项，但在NUMA计算机上实际可用的结点数目可能会少一些。因而该数组需要的项也会变少，内核在运行时对该结构分配比理论上更少的内存，就可以缩减该数组的项数。</p>

<p>但在UMA计算机上，这就不是问题，因为只有一个可用结点。</p>

<hr />

<p>用于管理slab链表的表头保存在一个独立的数据结构中，称为<em>kmem_list3</em>，代码如下：</p>

<h4 id="mmslabc-1">&lt;mm/slab.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">kmem_list3</span> <span class="p">{</span>
    <span class="cm">/* 首先是部分空闲链表，用于生成性能更好的汇编代码 */</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">slabs_partial</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">slabs_full</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">slabs_free</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">free_objects</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">free_limit</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">colour_next</span><span class="p">;</span>   <span class="cm">/* 各个节点的缓存着色 */</span>
    <span class="n">spinlock_t</span> <span class="n">list_lock</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">array_cache</span> <span class="o">*</span><span class="n">shared</span><span class="p">;</span> <span class="cm">/* 结点内存共享 */</span>
    <span class="k">struct</span> <span class="n">array_cache</span> <span class="o">**</span><span class="n">alien</span><span class="p">;</span> <span class="cm">/* 在其他节点上 */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next_reap</span><span class="p">;</span>    <span class="cm">/* 无需锁就可以更新的变量 */</span>
    <span class="kt">int</span> <span class="n">free_touched</span><span class="p">;</span>       <span class="cm">/* 同上 */</span>
<span class="p">};</span></code></pre></div>

<p>其中<em>free_objects</em>表示<em>slabs_partial</em>和<em>slabs_free</em>的所有slab中空闲对象的总数，<em>free_touched</em>表示缓存是否是active的，在从缓存获取一个对象时，内核将改变变量的值并设置为1。在缓存收缩时，重置为0。但内核只有在<em>free_touched</em>预先设置为0时，才会收缩内存<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>。</p>

<p>除了这些重要的字段以外，还有其他重要的字段如下。</p>

<table>
  <thead>
    <tr>
      <th>字段</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>next_reap</td>
      <td>定义了内核在两次尝试搜索缓存之间，必须经过的时间间隔，其想法时防止由于频繁的缓存收缩和增长操作而降低系统的性能，这种操作可能在某些系统负荷下发生</td>
    </tr>
    <tr>
      <td>free_limit</td>
      <td>指定了所有slab上容许未使用对象的最大数目</td>
    </tr>
    <tr>
      <td>free_objects</td>
      <td>所有未使用对象</td>
    </tr>
    <tr>
      <td>colorur_next</td>
      <td>各个节点的缓存着色</td>
    </tr>
  </tbody>
</table>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>如果启用了slab调试，buffer_size可能与对象的长度不同，因为每个对象都加入了额外的填充字节，在这种情况下，由另一个变量来表示对象的真正长度。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>并且free_couthced变量适用于整个缓存，而不同于per-CPU变量的touched。 <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#slab">#slab</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/tasklet/" class="pre">&lt; tasklet</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/wait-queue/" class="next">等待队列 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 内存管理_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章slab数据结构写于2014年05月10日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
