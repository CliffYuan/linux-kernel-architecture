<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>slab分配器|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 slab分配器..." name="description"/>
  <meta content="slab,分配器,备选分配器," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/slab/" />
  <meta property="og:title" content="slab分配器" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 slab分配器..." />
</head>
<body>

<div class="banner">
<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/" class="glyphicon glyphicon-inbox"> Home</a></li>
  <li><a href="/archive" class="glyphicon glyphicon-floppy-disk"> Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/" class="glyphicon glyphicon-book"> Kernel</a></li>
  <li><a href="/about" class="glyphicon glyphicon-record"> About</a></li>
</ul>
</div>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">slab分配器</div>

  <div class="content 内存管理_content_css">
    <p>每当我们要分配内存的时候，我们会使用malloc，malloc是C语言中分配内存的函数，我们可以使用malloc及其在C标准库中的相关函数，大多数程序分配若干字节内存时，经常会调用这些函数。内核也必须经常分配内存，但无法借助于标准库的函数，之前描述的伙伴系统支持按页分配内存，但这个单位对于内核而言实在太大了。</p>

<p>如果需要为一个10个字符的字符串分配空间，分配一个4KB或更多空间的完整页面，不仅仅浪费而且完全不可接收，所以内核需要将页拆分为更小的单位，以便可以容纳大量的小对象。</p>

<p>为此，内核必须引入新的管理机制，这会给内核带来更大的开销，为了最小化这个额外的负担对系统性能的影响，该管理层的实现应该尽可能的紧凑，以便不要对处理器的高速缓存TLB带来特别的影响。同事，内核还必须保证内存利用的速度和效率。</p>

<p>不仅Linux，而且类似的UNIX和所有其他的操作系统，都需要面对这个问题，经过一定的时间，已经提出了一些或好或坏的解决方案，在一般的操作系统的文献中都有讲解。其中slab分配的解决办法对许多特定的要求工作情况而言，都是非常高效的。</p>

<p>提供小内存块不是slab分配器的唯一任务，由于结构上的特点，它也用作一个缓存，主要针对经常分配并释放的对象。通过建立slab缓存，内核能够存储一些对象，供后续使用。即便在初始化状态也是如此。</p>

<p>例如，为管理与进程关联的文件系统数据，内核必须经常生成<em>struct fs_struct</em>的新实例，此类型实例占据的内存块同样需要经常回收<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。换句话说，内核趋向于非常有规律地分配并释放大小为<em>sizeof(fs_struct)</em>的内存块。</p>

<p>slab分配器将释放的内存块保存在一个内部列表中，并不能马上返回给伙伴系统。在请求为该类对象分配一个新实例时，会使用最近释放的内存块。这有两个有点，首先，由于内核不必使用伙伴系统算法，处理时间会变短，其次，由于该内存块仍然时新的，因此其仍然驻留在CPU高速缓存的概率较高。</p>

<p>slab分配器还有两个更进一步的好处：</p>

<ol>
  <li>调用伙伴系统的操作对系统的数据和指令高速缓存有相当的影响。内核越浪费这些资源，这些资源对用户空间进程就越不可用。更轻量级的slab分配器在可能的情况下减少了对伙伴系统的调用，有助于防止不受欢迎的缓存污染。</li>
  <li>如果数据存储在伙伴系统直接提供的页中，那么其地址总是出现在2的幂次数的整数倍附近。这对CPU高速缓存的利用有负面影响，由于这种地址分布，使得某些缓存行过度使用，而其他的则几乎为空。多处理器会更加剧这种不利情况，因为不同的内存地址可能在不同的总线上传输。</li>
</ol>

<p>通过slab着色（<em>slab coloring</em>），slab分配器能够均匀地分配对象，以实现均匀的缓存利用。着色这个术语时隐喻性的，它与颜色无关，只是表示slab中的对象需要移动的特定偏移量，以便使对象放置到不同的缓存行。</p>

<h3 id="section">备选分配器</h3>

<p>尽管slab分配器对许多可能的工作负荷都工作良好，但也有一些情形，它无法提供最优性能。如果某些计算机处于当前硬件尺度的边界上，这类计算机上使用slab分配会出现一些问题，例如微小的嵌入式系统，备有大量物理内存的大规模并行系统。在大规模系统中，slab分配器所需大量的元数据可能会成为更严重的问题<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>。</p>

<p>为了处理此类情况，内核版本在2.6开发期间，增加了slab分配器的两个替代品，分别为slob分配器和slub分配器。</p>

<p><strong>slob分配器</strong></p>

<p>slob分配器进行了特别的优化，以减少代码量，它围绕一个简单的内存块链表展开。在分配内存时，使用了同样简单的最先适配算法。slob分配器只有大约600行代码，总的代码量很小，但从速度上来说，它并不是最高效的分配器，也无法为大型系统所使用。</p>

<p><strong>slub分配器</strong></p>

<p>slub分配器通过将页帧打包为组，并通过<em>struct page</em>中未使用的字段来管理这些数组，试图最小化所需内存的开销，这样做不会简化该结构的定义，但是在大型计算机上，slub分配器比slab分配器提供了更好的性能。</p>

<hr />

<p>由于slab分配是大多数内核的默认选项，所以不会详细记录slob或slub分配器。但无论如何，内核都无需关心底层使用什么分配器，任何一种分配器对内核的接口都是相同的。</p>

<p class="center"><img src="/linux-kernel-architecture/images/slab.png" alt="slab" style="max-width:300px" /></p>

<p class="center">伙伴系统、通用分配器和内核代码之间的关系</p>

<p>普通内核代码只需要包含slab.h就可以使用内存分配的所有标准内核函数，连编系统会保证使用编译时选择的分配器来满足程序的内存分配请求。</p>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>在进程结束的时候。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>在大型系统上仅slab的数据结构就需要很多G字节内存，对嵌入式系统来说，slab分配器代码量和复杂性都太高。 <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#slab">#slab</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#分配器">#分配器</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#备选分配器">#备选分配器</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/multi-cpu-interrupt/" class="pre">&lt; 处理器间中断处理</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/soft-irq-and-tasklet/" class="next">软中断和tasklet &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 内存管理_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章slab分配器写于2014年05月07日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
