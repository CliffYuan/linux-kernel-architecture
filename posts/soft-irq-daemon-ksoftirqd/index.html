<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>软中断守护进程|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 软中断守护进程..." name="description"/>
  <meta content="软中断,ksoftirqd," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/soft-irq-daemon-ksoftirqd/" />
  <meta property="og:title" content="软中断守护进程" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 软中断守护进程..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/" class="glyphicon glyphicon-inbox"> Home</a></li>
  <li><a href="/archive" class="glyphicon glyphicon-floppy-disk"> Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/" class="glyphicon glyphicon-book"> Kernel</a></li>
  <li><a href="/about" class="glyphicon glyphicon-record"> About</a></li>
</ul>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">软中断守护进程</div>

  <div class="content 中断和异常_content_css">
    <p>我们知道如果不在中断上下文中调用<em>raise_softirq</em>方法，则调用<em>wakeup_softirq</em>来唤醒软中断守护进程，这个守护进程会执行软中断。软中断的守护进程的任务是，与其余内核代码异步执行软中断，为此，系统中每个处理分配器都有自己的守护进程，名为<em>ksoftirqd</em>。</p>

<p>内核中有两处调用了<em>wakeup_softirq</em>唤醒了该守护进程。</p>

<ol>
  <li>do_softirq中。</li>
  <li>在raise_softirq_irqoff末尾。</li>
</ol>

<p><em>raise_softirq_irqoff</em>函数由<em>raise_softirq</em>在内部调用，如果内核当前停用了中断，也可以直接使用。唤醒函数本身只需要几行代码，首先，借助于一些宏，从一个per-CPU变量读取指向当前CPU软中断守护进程的<em>task_struct</em>的指针。如果该进程当前的状态不是<em>TASK_RUNNING</em>的话，则通过<em>wake_up_process</em>将其置放到就绪进程列表的末尾。</p>

<p>尽管这并不会立即开始处理所有待决的软中断。但只要调度器没有更好的选择，就会选择用该守护进来执行。在系统启动时用<em>initcall</em>机制调用<em>init</em>不就，就创建了系统的软中断守护进程。代码如下：</p>

<h4 id="kernelsoftirqh">&lt;kernel/softirq.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kt">int</span> <span class="nf">ksoftirqd</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span> <span class="n">__bind_cpu</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

    <span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_KSOFTIRQD</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// 禁止抢占
</span>        <span class="n">preempt_disable</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">local_softirq_pending</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">preempt_enable_no_resched</span><span class="p">();</span>
            <span class="n">schedule</span><span class="p">();</span>
            <span class="n">preempt_disable</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">local_softirq_pending</span><span class="p">())</span> <span class="p">{</span>
            <span class="cm">/*
               禁止抢占会停止让CPU下线，如果已经下线，那么就
               正在一个错误的CPU上，那么就不要执行
               goto wait_to_die
            */</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cpu_is_offline</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">__bind_cpu</span><span class="p">))</span>
                <span class="k">goto</span> <span class="n">wait_to_die</span><span class="p">;</span>
            <span class="c1">// 执行软中断
</span>            <span class="n">do_softirq</span><span class="p">();</span>
            <span class="c1">// 可以抢占
</span>            <span class="n">preempt_enable_no_resched</span><span class="p">();</span>
            <span class="c1">// 确保对当前进程设置了TIE_NEED_RESCHED
</span>            <span class="c1">// 因为所有这些函数执行时都启用了硬件中断
</span>            <span class="n">cond_resched</span><span class="p">();</span>
            <span class="c1">// 禁止抢占
</span>            <span class="n">preempt_disable</span><span class="p">();</span>
            <span class="n">rcu_sched_qs</span><span class="p">((</span><span class="kt">long</span><span class="p">)</span><span class="n">__bind_cpu</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">preempt_enable</span><span class="p">();</span>
        <span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">wait_to_die:</span>
    <span class="n">preempt_enable</span><span class="p">();</span>
    <span class="cm">/* 等待kthread_stop停止 */</span>
    <span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">schedule</span><span class="p">();</span>
        <span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>每次被唤醒时，守护进程首先检查是否有标记出的待决软中断，否则明确地调用调度器，将控制软中断交给其他进程。如果有标记出的软中断，那么守护进程接下来将处理软中断。</p>

<p>进程在一个<em>while</em>循环中重复调用<em>do_softirq</em>和<em>cond_resched</em>，直至没有标记出的软中断位置。<em>con_resched</em>确保在对当前进程设置了<em>TIE_NEED_RESCHED</em>标志的情况下调用调度器，这是可能的，因为所有这些函数执行时都启用了硬件中断。</p>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#软中断">#软中断</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#ksoftirqd">#ksoftirqd</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/how-slab-work/" class="pre">&lt; slab分配的原理</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/tasklet/" class="next">tasklet &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 中断和异常_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章软中断守护进程写于2014年05月09日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
