<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>软中断|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 软中断..." name="description"/>
  <meta content="软中断," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/soft-irq/" />
  <meta property="og:title" content="软中断" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 软中断..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">daf94cf87</a></li>
  <!--
  I love bettylwx
    -->
</ul>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">软中断</div>

  <div class="content 中断和异常_content_css">
    <p>目前在我看的Linux代码中定义了10种软中断，分别如下，每个软中断的索引下标代表了优先级，下标越小优先级越大：</p>

<table class="table_center">
  <thead>
    <tr>
      <th>字段</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HI_SOFTIRQ</td>
      <td>处理高优先级tasklet</td>
    </tr>
    <tr>
      <td>TIMER_SOFTIRQ</td>
      <td>和时钟中断相关的tasklet</td>
    </tr>
    <tr>
      <td>NET_TX_SOFTIRQ</td>
      <td>把数据包传送到网卡</td>
    </tr>
    <tr>
      <td>NET_RX_SOFTIRQ</td>
      <td>从网卡接受数据包</td>
    </tr>
    <tr>
      <td>BLOCK_SOFTIRQ</td>
      <td>块设备软中断</td>
    </tr>
    <tr>
      <td>BLOCK_IOPOLL_SOFTIRQ</td>
      <td>支持IO轮询的块设备软中断</td>
    </tr>
    <tr>
      <td>TASKLET_SOFTIRQ</td>
      <td>处理常规的IRQ</td>
    </tr>
    <tr>
      <td>SCHED_SOFTIRQ</td>
      <td>调度程序软中断</td>
    </tr>
    <tr>
      <td>HRTIMER_SOFTIRQ</td>
      <td>高精度计时器软中断</td>
    </tr>
    <tr>
      <td>RCU_SOFTIRQ</td>
      <td>RCU锁软中断</td>
    </tr>
    <tr>
      <td>NR_SOFTIRQS</td>
      <td>当前Linux内核允许注册的最大软中断数</td>
    </tr>
  </tbody>
</table>

<p>代码可以看到：</p>

<h4 id="includelinuxinterrupth">&lt;include/linux/interrupt.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">enum</span>
<span class="p">{</span>
    <span class="n">HI_SOFTIRQ</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
    <span class="n">TIMER_SOFTIRQ</span><span class="p">,</span>
    <span class="n">NET_TX_SOFTIRQ</span><span class="p">,</span>
    <span class="n">NET_RX_SOFTIRQ</span><span class="p">,</span>
    <span class="n">BLOCK_SOFTIRQ</span><span class="p">,</span>
    <span class="n">BLOCK_IOPOLL_SOFTIRQ</span><span class="p">,</span>
    <span class="n">TASKLET_SOFTIRQ</span><span class="p">,</span>
    <span class="n">SCHED_SOFTIRQ</span><span class="p">,</span>
    <span class="n">HRTIMER_SOFTIRQ</span><span class="p">,</span>
    <span class="n">RCU_SOFTIRQ</span><span class="p">,</span>    <span class="cm">/* 最后一个软中断 */</span>
    <span class="cm">/* 当前Linux内核允许注册的最大软中断数 */</span>
    <span class="n">NR_SOFTIRQS</span>
<span class="p">};</span></code></pre></div>

<p>其中<em>HI_SOFTIRQ</em>和<em>TIMER_SOFTIRQ</em>用来实现tasklet。</p>

<p>表示软中断的主要数据结构是<em>softirq_vec</em>数组，这个数组包含类型为<em>softirq_action</em>的32个元素，<em>softirq_action</em>代码如下：</p>

<h4 id="includelinuxinterrupth-1">&lt;include/linux/interrupt.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">softirq_action</span>
<span class="p">{</span>
    <span class="kt">void</span>    <span class="p">(</span><span class="o">*</span><span class="n">action</span><span class="p">)(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span></code></pre></div>

<p>一个软中断的优先级是相应的<em>softirq_action</em>元素在数组内的下标，<em>softirq_action</em>数据结构含有一个字段，指向中断函数的一个action指针。</p>

<p>另外一个关键字段是<em>preempt_count</em>字段，用它来跟踪内核抢占和内核控制路径的嵌套，该字段存放在每个进程描述符的<em>thread_info</em>字段中。<em>preempt_count</em>字段的编码表示三个不同的计数器和一个标志：</p>

<table class="table_center">
  <thead>
    <tr>
      <th>字段</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>0~7</td>
      <td>抢占计数器</td>
    </tr>
    <tr>
      <td>8~15</td>
      <td>软中断计数器</td>
    </tr>
    <tr>
      <td>16~27</td>
      <td>硬中断计数器</td>
    </tr>
    <tr>
      <td>28</td>
      <td>PREEMPT_ACTIVE标志</td>
    </tr>
  </tbody>
</table>

<p>第一个计数器记录显式禁用本地CPU内核抢占的次数，值等于0表示允许内核抢占。第二个计数器表示可延迟函数被禁用的成都，值为0表示可延迟函数处于激活状态。第三个计数器表示本地CPU上中断处理的嵌套数。</p>

<p><em>preempt_count</em>字段表示：当内核代码明确不允许发生抢占，或当内核正在中断上下文中运行时，必须禁用内核的抢占功能。因此，为了确定是否能抢占当前进程，内核快速检查<em>preempt_count</em>字段中的相应的值是否等于0。</p>

<p>宏<em>in_interrupt</em>检查<em>preempt_count</em>字段产生的硬件中断计数器和软中断计数器，只要这两个计数器中的一个值为正数，该宏就产生一个非零的值。</p>

<h4 id="includelinuxhardirqh">&lt;include/linux/hardirq.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="cp">#define irq_count() (preempt_count()
</span>    <span class="o">&amp;</span> <span class="p">(</span><span class="n">HARDIRQ_MASK</span> <span class="o">|</span> <span class="n">SOFTIRQ_MASK</span> <span class="o">|</span> <span class="n">NMI_MASK</span><span class="p">))</span>

<span class="cp">#define in_interrupt() (irq_count())</span></code></pre></div>

<p>如果内核不使用多内核栈，则该宏只检查当前进程的<em>thread_info</em>描述符的<em>preempt_count</em>字段，但是如果内核使用多内核栈，则该宏可能还要检查本地CPU的<em>irq_ctx</em>结构中的<em>thread_info</em>描述符的<em>preempt_count</em>字段，在这种情况下由于该字段总是正数值，所以返回非零值。</p>

<p>实现软中断的最后一个关键数据结构是每个CPU都有的32位掩码，它存放在<em>irq_cpustat_t</em>数据结构的<em>__softirq_pending</em>字段中，在系统中，每个CPU都有一个这样的数据结构。</p>

<p>软中断必须首先注册，然后内核才能执行软中断。<em>open_softirq</em>函数用来注册一个软中断，它在<em>softirq_vec</em>表中指定的位置写入新的软中断：</p>

<h4 id="kernelsoftirqh">&lt;kernel/softirq.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">open_softirq</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">action</span><span class="p">)(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
    <span class="n">softirq_vec</span><span class="p">[</span><span class="n">nr</span><span class="p">].</span><span class="n">action</span> <span class="o">=</span> <span class="n">action</span><span class="p">;</span>
<span class="p">}</span></code></pre></div>

<p>每个软中断都有一个唯一的编号，这说明软中断是相对稀缺的资源，使用其必须要小心，不能由各种设备和内核组件随意的使用，默认情况下，系统上只能使用32个软中断。但这个限制不会有太大的局限性，因为软中断充当实现其他延迟执行机制的函数，而且也很适合设备驱动程序。</p>

<p>只有中枢代码可以使用软中断，软中断只用于几个少数场合，这些都是相对重要的场合。</p>

<p><em>raise_softirq</em>用于引发一个软中断，编号通过参数指定，这个函数将相应的软中断执行，但这个执行是延迟执行，并不是立即执行的。通过特定于处理器的位图，内核确保多个软中断能够公平的在不同的CPU上执行。</p>

<h4 id="kernelsoftirqh-1">&lt;kernel/softirq.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">raise_softirq</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

    <span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
    <span class="n">raise_softirq_irqoff</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>
    <span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>如果不在中断上下文中调用<em>raise_softirq</em>方法，则调用<em>wakeup_softirq</em>来唤醒软中断守护进程，这个守护进程会执行软中断。</p>

  </div>

  <hr>
  <div class="eof">EOF</div>
  <hr>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#软中断">#软中断</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/kernel-mm-management/" class="pre">&lt; 内核中的内存管理</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/how-slab-work/" class="next">slab分配的原理 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 中断和异常_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章软中断写于2014年05月08日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
