<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>tasklet|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 tasklet..." name="description"/>
  <meta content="tasklet," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/tasklet/" />
  <meta property="og:title" content="tasklet" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 tasklet..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">Home</a></li>
  <li><a href="/archive/">Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/">Kernel</a></li>
</ul>

</div>

<div class="container">

<div class="main clearfix">
  <div class="title">tasklet</div>

  <div class="content 中断和异常_content_css">
    <p>软中断是将操作推迟到未来某一个时刻执行的最好方法，但延迟函数执行以及处理机制非常复杂。因为多个处理器是可以同时并且独立地处理软中断，同一个软中断的处理程序例程可以在几个CPU上同时运行。</p>

<p>对软中断的效率来说，这是一个关键，多处理器上的网络实现依靠于此。但处理程序例程的设计必须是完全可重入且线程安全的。另外，临界区必须使用自旋锁保护，或者其他的IPC机制<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>。</p>

<p>tasklet和工作队列是延迟函数执行工作的机制，其实现基于软中断，但是tasklet更易于使用，因而是更适用于设备的驱动程序一起其他一般性的内核代码。</p>

<h3 id="tasklet">tasklet结构</h3>

<p>tasklet是『小进程』，执行一些迷你的任务，对这些任务使用全功能进程会过于浪费。tasklet的结构定义如下：</p>

<h4 id="includelinuxinterrupth">&lt;include/linux/interrupt.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">tasklet_struct</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">state</span><span class="p">;</span>
    <span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>
    <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span></code></pre></div>

<p>从设备驱动程序来看，最重要的成员是<em>func</em>，它指向一个函数的地址，该函数的执行将被延期执行。<em>data</em>用作该函数执行时的参数。其中<em>next</em>是一个指针，用于建立一个<em>tasklet_struct</em>的链表，这容许多个任务能够派对执行。其中<em>state</em>表示任务的当前状态，类似于真正的进程但是只有两个选项。</p>

<ol>
  <li>当tasklet注册到内核，等待调度执行时，将设置<em>TASKLET_STATE_SCHED</em>。</li>
  <li><em>TASKLET_STATE_RUN</em>表示<em>tasklet</em>当前正在执行。</li>
</ol>

<p>第二个状态只在SMP系统上有用，用于保护<em>tasklet</em>在多个处理器上并行执行。原子计数器<em>count</em>用于禁用已经调度的<em>tasklet</em>，如果其值不等于0，在接下来执行的所有等待的tasklet任务时，将忽略对应的tasklet。</p>

<h3 id="tasklet-1">注册tasklet</h3>

<p><em>tasklet_schedule</em>将一个tasklet注册到系统中：</p>

<h4 id="includelinuxinterrupth-1">&lt;include/linux/interrupt.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">tasklet_schedule</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">TASKLET_STATE_SCHED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
        <span class="n">__tasklet_schedule</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p>其中<em>test_and_set_bit</em>函数是一个<a href="/linux-kernel-architecture/posts/atomic-operations/">原子操作</a>，其作用是设置<em>&amp;t-&gt;state</em>的<em>TASKLET_STATE_SCHED</em>位并返回原值。如果设置了<em>TASKLET_STATE_SCHED</em>标志位，则已经注册了tasklet，则返回。否则，将该tasklet至于一个链表的起始，其表头特定于CPU的变量<em>tasklet_vec</em>向量，该链表包含了所有注册的<em>tasklet</em>。</p>

<p>在注册了一个tasklet之后， tasklet链表即标记为即将进行处理。</p>

<h3 id="tasklet-2">执行tasklet</h3>

<p>tasklet生命周期中最为重要的部分就是执行，因为tasklet基于软中断实现，它们总是在处理软中断时执行。</p>

<p><em>tasklet</em>关联到<em>TASKLET_SOFTIRQ</em>软中断，因而，调用<em>raise_softirq(TASKLET_SOFTIRQ)</em>就可以在下一个恰当的实际执行当前处理器的tasklet。内核使用<em>tasklet_action</em>作为该软中断的action函数。</p>

<p>这个函数首先确定特定于CPU的链表，其中保存了标记要执行的各个tasklet，它接下来将表头重定向到函数局部的一个数据项，相当于从外部公开的链表删除了所有表项，接下来，函数在循环中逐一处理tasklet。</p>

<h4 id="kernelsoftirqh">&lt;kernel/softirq.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kt">void</span> <span class="nf">tasklet_action</span><span class="p">(</span><span class="k">struct</span> <span class="n">softirq_action</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">list</span><span class="p">;</span>
    <span class="c1">// 禁用本地irq
</span>    <span class="n">local_irq_disable</span><span class="p">();</span>
    <span class="c1">// 从外部链表删除当前CPU的tasklet项
</span>    <span class="n">list</span> <span class="o">=</span> <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tasklet_vec</span><span class="p">).</span><span class="n">head</span><span class="p">;</span>
    <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tasklet_vec</span><span class="p">).</span><span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tasklet_vec</span><span class="p">).</span><span class="n">tail</span> <span class="o">=</span> 
        <span class="o">&amp;</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tasklet_vec</span><span class="p">).</span><span class="n">head</span><span class="p">;</span>
    <span class="c1">// 启用本地irq
</span>    <span class="n">local_irq_enable</span><span class="p">();</span>

    <span class="c1">// 循环链表处理
</span>    <span class="k">while</span> <span class="p">(</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>

        <span class="n">list</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">tasklet_trylock</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
                <span class="c1">// 清楚相应的比特位
</span>                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">TASKLET_STATE_SCHED</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">))</span>
                    <span class="n">BUG</span><span class="p">();</span>
                <span class="c1">// 处理注册的函数
</span>                <span class="n">t</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">);</span>
                <span class="n">tasklet_unlock</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">tasklet_unlock</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">local_irq_disable</span><span class="p">();</span>
        <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="o">*</span><span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tasklet_vec</span><span class="p">).</span><span class="n">tail</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
        <span class="n">__get_cpu_var</span><span class="p">(</span><span class="n">tasklet_vec</span><span class="p">).</span><span class="n">tail</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
        <span class="n">__raise_softirq_irqoff</span><span class="p">(</span><span class="n">TASKLET_SOFTIRQ</span><span class="p">);</span>
        <span class="n">local_irq_enable</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></div>

<p>其中<em>test_and_clear_bit</em>也是一个<a href="/linux-kernel-architecture/posts/atomic-operations/">原子操作</a>，与<em>test_and_set_bit</em>相反，其作用是清除相应的比特位。</p>

<p>因为一个tasklet只能在一个处理器上执行一次，但其他的tasklet可以并行执行，所以需要特定于tasklet的锁。<em>state</em>状态用作锁变量，在执行一个tasklet的处理程序函数之前，内核使用<em>tasklet_trylock</em>检查tasklet的状态是否是<em>TASKLET_STATE_RUN</em>。</p>

<h4 id="includelinuxinterrupth-2">&lt;include/linux/interrupt.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tasklet_trylock</span><span class="p">(</span><span class="k">struct</span> <span class="n">tasklet_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">TASKLET_STATE_RUN</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span></code></pre></div>

<p><em>tasklet_trylock</em>函数检查如果对应的比特位尚未设置，则设置该比特位。</p>

<p>如果<em>count</em>成员不为0，则该tasklet已经停用，在这种情况下就不执行相关的代码。否则就通过<em>t-&gt;func(t-&gt;data)</em>执行相应的函数。如果在执行tasklet期间，有新的tasklet进入当前处理器的tasklet队列，则会尽快引发<em>TASKLET_SOFTIRQ</em>r软中断来执行新的tasklet。</p>

<p>除了普通的tasklet之外，内核还使用了另一种tasklet，它具有『较高』的优先级，除以下修改之外，其实现与普通的tasklet完全相同。</p>

<ol>
  <li>使用HI_SOFTIRQ作为软中断，而不是TASKLET_SOFTIRQ。</li>
  <li>注册tasklet在CPU的相关变量的tasklet_hi_vec中站队。</li>
</ol>

<p>当前大部分声卡驱动程序都利用了这一选项，因为操作延迟时间太长可能损害音频输出的音质。</p>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>具体可以看后面的内核同步的笔记。 <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#tasklet">#tasklet</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/soft-irq-daemon-ksoftirqd/" class="pre">&lt; 软中断守护进程</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/slab-structure/" class="next">slab数据结构 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 中断和异常_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章tasklet写于2014年05月09日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
