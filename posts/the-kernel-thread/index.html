<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>内核线程|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 内核线程..." name="description"/>
  <meta content="内核线程,idel,swapper,init,守护进程," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/the-kernel-thread/" />
  <meta property="og:title" content="内核线程" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 内核线程..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">daf94cf87</a></li>
  <!--
  I love bettylwx
    -->
</ul>
</div>

<div class="container">

<div class="main clearfix">
  <div class="title">内核线程</div>

  <div class="content 进程_content_css">
    <p>内核线程（<em>kernel thread</em>）是直接由内核本身启动的进程，内核线程实际上是将内核函数委托给独立的进程，与系统中其他进程『并行』执行。内核线程经常被称之为守护进程。它们用于执行下列任务：</p>

<ol>
  <li>周期性地将修改的内存页与页面来源块设备同步。</li>
  <li>如果内存页很少使用，则写入交换区。</li>
  <li>管理延时动作。</li>
  <li>实现文件系统的事物日志。</li>
</ol>

<p>基本上，有两种类型的内核线程：</p>

<ol>
  <li>线程启动后一直等待，直至内核请求线程执行某一特定的操作。</li>
  <li>线程启动后按周期性间隔运行，监测特定的资源使用，在用量超出或者低于预置的限制时采取行动。</li>
</ol>

<p>这些任务包括刷新磁盘高速缓存，交换出不用的页框，维护网络连接等等。实际上，如果以严格的线性方式执行这些任务效率不高，如果把它们放在后台调度，则会有较好的效率。这些任务委托给内核线程，内核线程不受不必要的用户态上下文的拖累，内核线程和普通进程的区别有：</p>

<ol>
  <li>内核线程只运行在内核态，而普通进程既可以运行在内核态，也可以运行在用户态。</li>
  <li>因为内核线程只运行在内核态，它们只使用大于PAGE_OFFSET的线性地址空间。普通进程可以使用4GB的线性地址空间。</li>
</ol>

<p>调用kernel_thread函数可以启动一个内核线程。</p>

<h4 id="asm-archprocessorh">&lt;asm-arch/processor.h&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">int</span> <span class="n">kernel_thread</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span> <span class="n">arg</span><span class="p">,</span>
                  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span></code></pre></div>

<p>产生的线程将执行<em>fn</em>指针传递的函数，以便内核线程可以根据函数的不同而执行不同的函数，而用<em>arg</em>指定的参数将自动化传递给该函数。</p>

<p>大多数计算机上的系统的全部虚拟地址空间分成两部分：地步可以由用户层程序访问，上部则专供内核使用。在内核代表用户层运行时，虚拟地址空间的用户空间部分有<em>mm</em>指向<em>mm_struct</em>实例描述。每当内核执行上下文切换时，虚拟地址空间的用户层部分都会切换，以便与当前运行的进程匹配。</p>

<p>这为优化提供了一些方法，可遵循所谓的惰性TLB处理。由于内核线程不与任何特定的用户层进程相关，内核不需要倒换虚拟地址空间的用户层部分。由于内核线程之前可能有其他用户层进程在执行，因此用户空间部分的内存本质上时随机的。内核线程绝不能修改其内容。</p>

<p>为强调用户空间部分不能访问，<em>mm</em>设置为空指针。但由于内核必须知道用户空间当前包含了什么，所以在<em>active_mm</em>中保存了指向<em>mm_struct</em>的一个指针来描述它。</p>

<p>内核线程可以用两种方法实现。第一种是将一个函数直接传递给kernel_thread，这个函数接下来负责帮助内核调用daemonize以转换为守护进程。将触发下列操作。</p>

<ol>
  <li>该函数从内核线程释放其父进程的所有资源，因为守护进程只操作内核地址区域，不需要这些资源。</li>
  <li>daemonize阻塞信号的接受。</li>
  <li>将init用作守护进程的父进程。</li>
</ol>

<p><em>kthread_create</em>帮助创建内核线程。</p>

<h4 id="kernelkthreadc">&lt;kernel/kthread.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">kthread_create</span><span class="p">(</span><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">threadfn</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">),</span>
                                   <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="kt">char</span> <span class="n">namefmt</span><span class="p">[],</span>
<span class="p">)</span></code></pre></div>

<p>另一个被选方案是使用宏指令<em>kthread_run</em>，参数与<em>thread_create</em>相同。它会调用<em>kthread_create</em>创建新线程，但是立即唤醒它。</p>

<h3 id="section">进程0</h3>

<p>所有进程的祖先叫做进程0，<em>idle</em>进程，因为历史原因也可叫做<em>swapper</em>进程，它是在Linux的初始化阶段从无到有创建的一个内核线程。</p>

<h3 id="section-1">进程1</h3>

<p>由进程0创建的内核线程执行init()函数，init()依次完成内核初始化。init()调用execve()系统调用转入可执行程序<em>init</em>，<em>init</em>内核线程变为一个普通进程，且拥有自己的每进程内核数据结构。在系统关闭之前，<em>init</em>进程一直存活，因为它创建和监控在操作系统外层执行的所有进程的活动。</p>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#内核线程">#内核线程</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#idel">#idel</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#swapper">#swapper</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#init">#init</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#守护进程">#守护进程</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/process-waiting-link-list/" class="pre">&lt; 组织进程</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/clone-fork-and-vfork/" class="next">进程复制 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments 进程_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章内核线程写于2014年04月10日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
