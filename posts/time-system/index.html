<!DOCTYPE HTML>
<html>
<!-- <html> -->
<head>
  <title>时钟和定时器电路|Linux Kernel Architecture 内核笔记</title>
  <meta charset="utf-8" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/feed.xml">
<link rel="icon" href="/images/icons/avatar.png">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="/style/css/bootstrap.css" type="text/css" media="screen">
<link rel="stylesheet" href="/style/css/syntax.css" type="text/css" media="screen">
<script type="text/javascript" src="/style/jquery-1.7.1.min.js"></script>


<link rel="stylesheet" href="/style/style.css" type="text/css">

<script>
$(document).ready(function(){
    $('.nav a').hover(
        function(){
            $(this).animate({opacity: 0.3}, 400)
        }, 
        function(){
            $(this).animate({opacity: 1}, 400)
        });
});
function getURLParameter(name) {
    return decodeURI(
        (RegExp(name + '=' + '(.+?)(&|$)').exec(location.search)||[,null])[1]
    );
}
</script>

<style>
.archive li {
    list-style: decimal;
    margin-left: 50px;
    line-height: 2em;
}

.archive .year {
    list-style: none;
}
</style>
  <script type="text/javascript">
        var BYB = {};
  </script>
  <script type="text/javascript">
    BYB.includeScript = function(file,callback){
    var _doc = document.getElementsByTagName('head')[0];
    var js = document.createElement('script');
    js.setAttribute('type', 'text/javascript');
    js.setAttribute('src', file);
    _doc.appendChild(js);
    
    if (!/*@cc_on!@*/0) { //if not IE
    //Firefox2、Firefox3、Safari3.1+、Opera9.6+ support js.onload
    js.onload = function () {
    callback();
    }
    } else {
    //IE6、IE7 support js.onreadystatechange
    js.onreadystatechange = function () {
    if (js.readyState == 'loaded' || js.readyState == 'complete') {
    callback();
    }
    }
    }
    return false;
    }
  </script>
  <meta content="linux kernel architecture 内核笔记 时钟和定时器电路..." name="description"/>
  <meta content="时钟,定时器电路,RTC,TSC,PIT,ACPI," name="keywords"/>
  <meta property="og:type" content="article" />
  <meta property="og:url" content="http://guojing.me/linux-kernel-architecture//posts/time-system/" />
  <meta property="og:title" content="时钟和定时器电路" />
  <meta property="og:description" content="linux kernel architecture 内核笔记 时钟和定时器电路..." />
</head>
<body>

<div class="banner">
<ul class="nav nav-pills">
  <li><a href="/">Home</a></li>
  <li><a href="/archive/">Archive</a></li>
  <li><a href="/linux-kernel-architecture/archive/">Kernel</a></li>
</ul>

</div>

<div class="container">

<div class="main clearfix">
  <div class="title">时钟和定时器电路</div>

  <div class="content timing定时测量_content_css">
    <p>在80x86体系结构上，内核必须显式地与几种时钟和定时电路打交道，时钟电路同时用于跟踪当前时间和产生精确的时间度量。定时器电路由内核编程，所以它们以固定的、预先定义的频率发出中断。这样的周期性中断对于实现内核和用户程序使用的软定时器都是非常重要的，这里有几种IBM兼容PC上的时钟和硬件电路。</p>

<h3 id="rtc">实时时钟 - RTC</h3>

<p>所有的PC都包含一个叫实时时钟（<em>Renl Time Clock RTC</em>）的时钟，它是独立于CPU和所有其他芯片的。</p>

<p>即使当PC被切断电源，RTC依旧继续工作，因为它靠一个小电池或蓄电池供电。CMOS TAM和RTC被继承在一个芯片<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup>上。</p>

<p>RTC能在IRQ8上发出周期性的中断，频率在2～8192Hz之间，也可以对RTC进行编程以使当RTC到达某个特定的值时激活IRQ8线，也就是作为一个闹钟来工作。</p>

<p>Linux只用RTC来获取时间和日期，不过通对<em>/dev/rtc</em>设备文件进行操作，也允许进程对RTC编程。内核通过0x7x和0x71 I/O端口访问RTC。系统管理员通过执行Unix系统时钟程序可以设置时钟。</p>

<h3 id="tsc">时间戳计数器 - TSC</h3>

<p>所有的80x86微处理器都包含一条CLK输入引线，它接收玩不振荡器的时钟信号。从Pentium开始，80x86微处理器就都包含一个计数器，它在每个时钟信号到来时加1。该计数器是利用64位的时间戳计数器（<em>Time Stamp Counter TSC</em>）寄存器来实现的，可以通过汇编语言指令<em>rdtsc</em>来读这个寄存器。当使用这个寄存器时，内核必须考虑到时钟信号的频率，例如时钟节拍的频率时1GHz，那么时间戳计数器每那庙增加一次。</p>

<p>与可编程间隔定时器传递来的时间测量相比，Linux利用这个寄存器可获得更精确的时间测量，为了做到这点，Linux在初始化系统的时候必须确定时钟信号的频率。因为编译内核时并不声明这个频率，所以同一内核映象可以运行在产生任何时钟频率的CPU上。</p>

<p>算出CPU实际频率的任务时在系统初始化期间完成的。<em>calibrate_tsc()</em>函数通过计算一个大约在5ms的时间间隔内所产生的时钟信号的个数算出CPU实际的频率。通过适当地设置可编程间隔定时器的一个通道来产生这个时间常量。</p>

<p>在x86平台初始化的代码可以看到，<em>calibrate_tsc</em>被初始化为<em>native_calibrate_tsc</em>。</p>

<h4 id="archx86kernelx86initc">&lt;arch/x86/kernel/x86_init.c&gt;</h4>

<div class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">struct</span> <span class="n">x86_platform_ops</span> <span class="n">x86_platform</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">.</span><span class="n">calibrate_tsc</span>          <span class="o">=</span> <span class="n">native_calibrate_tsc</span><span class="p">,</span>
    <span class="p">.</span><span class="n">get_wallclock</span>          <span class="o">=</span> <span class="n">mach_get_cmos_time</span><span class="p">,</span>
    <span class="p">.</span><span class="n">set_wallclock</span>          <span class="o">=</span> <span class="n">mach_set_rtc_mmss</span><span class="p">,</span>
<span class="p">};</span></code></pre></div>

<p>其中<em>native_calibrate_tsc</em>代码在文件<em>&lt;arch/x86/kernel/tsc.c&gt;</em>中。</p>

<h3 id="pit">可编程间隔定时器 - PIT</h3>

<p>除了实时时钟和时间戳计数器，IBM兼容PC还包含第三种类型的时间测量设备叫做可编程间隔定时器（<em>Programmable Interval Timer PIT</em>）。PIT的作用类似于微波炉的闹钟，让用户意识到烹饪调整的时间见过已经过去了。不同的是，这个设备不是通过震铃，而是发出一个特殊的中断，叫做时钟中断（<em>timer interrupt</em>）来通知内核又一个时间间隔过去了。</p>

<p>Linux给PC的第一个PIT进行编程，使它以大约1000Hz的频率向IRQ0发出时钟中断，即每1ms产生一次时钟中断。这个时间间隔叫做一个节拍（<em>tick</em>），它的长度以纳秒为单位放在<em>tick_nsec</em>变量中。</p>

<p>一般而言，短的节拍产生较高分辨率的定时器，当这种定时器执行同步I/O多路复用<sup id="fnref:1:1"><a href="#fn:1" class="footnote">1</a></sup>时，有助于多媒体的平滑播放和较快的响应时间。不过，这是一种折中，段的节拍需要CPU在内核态花费更多的时间，也就是在用户态花费较少的时间。因而，用户程序运行得稍微慢一些。</p>

<p>时钟中断的频率取决于硬件体系结构，较慢的机器节拍大约为10ms，而较快的机器节拍为大约1ms。在Linux代码中，有几个宏产生决定时钟中断频率的常量：</p>

<ol>
  <li>HZ产生美妙时钟中断的近似个数，也就是时钟中断的频率，在IBM PC下其值设置为1000。</li>
  <li>CLOCK_TICK_RATE产生的值为1193182，这个值是8254芯片的内部震荡器频率。</li>
  <li>LATCH产生CLOCK_TICK_RATE和HZ的比值再四舍五入后的整数值，这个值用来对PIT编程。</li>
</ol>

<h3 id="cpu">CPU本地定时器</h3>

<p>在最近的80x86微处理的本地APIC中还提供了另一种定时测量设备，即CPU本地定时器。</p>

<p>CPU本地定时器是一种能够产生单步中断或周期性中断的设备，它类似于刚才描述的可编程间隔定时器，不过，还是有几种区别：</p>

<ol>
  <li>APIC计数器是32位，而PIC的计数器是16位，因此，可以对本地定时器编程来产生很低频率的中断。</li>
  <li>本地APIC定时器把中断值发送给自己的处理器，而PIT产生一个全局性的中断，系统中的任一CPU都可以对其进行处理。</li>
  <li>APIC定时器是基于总线时钟信号的，每隔1，2，4，8，16，32，64或128总线时钟信号到来时对该定时器进行递减可以实现对其编程的目的。相反，PIT有其自己的内部时钟振荡器，可以更灵活的编程。</li>
</ol>

<h3 id="section">高精度事件定时器</h3>

<p>高精度事件定时器是由Intel和Microsoft联合开发的一种新型定时器芯片，尽管这种定时器在终端用户机器上还不普遍，但Linux 2.6已经能够支持它们。</p>

<p>HPET提供了许多可以被内核使用的硬件定时器，这种新定时器芯片主要包含8个32位或64位的独立计数器。每个计数器由它自己的时钟信号所驱动，该时钟信号的频率必须至少位10MHz，因此，计数器最少可以每100ns增长一次。任何计数器最多可以与32个定时器相关联，每个定时由一个比较器和一个匹配寄存器组成。比较器是一组用于检测计数器中的值与匹配寄存器中的值是否匹配的电路，如果找到一组匹配值就产生一个硬件中断，一些定时器可以被激活来产生周期性中断。</p>

<p>可以通过映射到内存空间的寄存器来对HPET芯片编程。BIOS在自举阶段建立起映射并向操作系统内核报告它的起始内存地址。HPET寄存器允许内核对计数器和匹配寄存器的值进行读和写，允许内核对单步中断进行编程，还允许内核再支持HPET的定时器上激活或禁止周期性中断。</p>

<h3 id="acpi">ACPI电源管理定时器</h3>

<p>ACPI电源管理定时器<sup id="fnref:2"><a href="#fn:2" class="footnote">2</a></sup>是另一种时钟设备，包含再几乎所有基于ACPI的主板上。它的时钟信号拥有大约位3.58MHz的固定频率。该舍比实际上是一个简单的计数器，它再每个时钟节拍到来时增加一次。为了读取计数器的当前值，内核需要访问某个I/O端口，该端口的地址由BIOS在初始化阶段确定。</p>

<p>如果操作系统或者BIOS可以通过动态降低CPU的工作频率或者工作典雅来节省电池的电能，那么ACPI电源管理定时器就比TSC更优越。当发生这种情况时，TSC的频率发生改变，而ACPI PMT的频率不会改变。另一方面，TSC计数器的高频率非常便于测量特别小的时间间隔。</p>

<p>不过，如果系统中存在HPET设备，那么比起其他的电路而言它总是首选，因为它更复杂的结构使得功能更强。</p>
<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>例如poll()或者select()。 <a href="#fnref:1" class="reversefootnote">&#8617;</a> <a href="#fnref:1:1" class="reversefootnote">&#8617;<sup>2</sup></a></p>
    </li>
    <li id="fn:2">
      <p>也称ACPI PMT。 <a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>

  </div>

  <div class="forb">
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#时钟">#时钟</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#定时器电路">#定时器电路</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#RTC">#RTC</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#TSC">#TSC</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#PIT">#PIT</a>
  
  <a href="http://guojing.me/linux-kernel-architecture/tags/#ACPI">#ACPI</a>
  
  </div>

  <div class="suggest">
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/atomic-operations/" class="pre">&lt; 原子操作</a>
    
    
    
        <a href="http://guojing.me/linux-kernel-architecture/posts/memory-barrier/" class="next">优化和内存屏障 &gt;</a>
    
    </div>
</div>

<!--
<div class="comments timing定时测量_comments_css">
<div id="disqus_container"> 
    
    <a href="#" class="comment" onclick="return false;">点击评论或查看评论。</a>
        
    <div id="disqus_thread"></div>
</div>
</div>
-->

<script type="text/javascript">
    $(document).ready(function(){
        $('#disqus_container .comment').on('click',function(){
            $(this).html('加载中...');
    var disqus_shortname = 'jguoer';
            var that = this;
            BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()});
        });
});
</script>

<!--
  Copryright GuoJing 未经允许，严禁直接从Github上转载我的文章，所有文章遵循CC协议，允许复制和转载，但需要保留原作者链接。
  该文章时钟和定时器电路写于2014年04月28日。
-->

</div>
<div class="footer">
<!--
    Copyright GuoJing, Theme designed by GuoJing
    Theme name Simple
    If you love this theme, please keep my copyright and link to my blog.
    If you DON'T LIKE it and you CAN remove the link. but not share spirit.
    如果你喜欢这个博客构架和皮肤，请保留我作为原作者的权利，我会感谢你。
    你也可以不保留我作为原作者的权利，自然没有任何问题，但似乎没有共享精神。
-->
<!-- © Copryright by<a href="http://guojing.me/" target="_blank">GuoJing</a> 2012-2014 using <a href="http://www.github.com/" target="_blank">GitHub</a> and <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> -->
<div class="author">
    <div class="icon">
        <img src="/images/authors/guojing.jpg" alt="me"/>
    </div>
    <div class="name">
        <a href="/about">GuoJing</a>
    </div>
    <div class="description">
        Linux Kernel Architecture 内核笔记
    </div>
</div>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-42721249-1', 'guojing.me');
  ga('send', 'pageview');

</script>
</div>

</body>
</html>
